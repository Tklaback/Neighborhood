'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
var TEST_API_URL = 'https://test.stytch.com';
var LIVE_API_URL = 'https://api.stytch.com';
var CLIENTSIDE_SERVICES_IFRAME_URL = 'https://js.stytch.com/clientside-services/index.html';
var STYTCH_WEB_BACKEND_URL = "https://web.stytch.com";
var STYTCH_SESSION_COOKIE = 'stytch_session';
var STYTCH_SESSION_JWT_COOKIE = 'stytch_session_jwt';
var POWERED_BY_STYTCH_IMG_URL = 'https://public-assets.stytch.com/et_powered_by_stytch_logo.png';
var GOOGLE_ONE_TAP_HOST = 'https://accounts.google.com/gsi';
var GOOGLE_ONE_TAP_SCRIPT_URL = "".concat(GOOGLE_ONE_TAP_HOST, "/client");
var STYTCH_CSRF_TOKEN_NAME = 'stytch_csrf_private_token';
var DEFAULT_SESSION_DURATION_MINUTES = 30;
var DEFAULT_OTP_EXPIRATION_MINUTES = 5;
/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */

var Products;

(function (Products) {
  Products["emailMagicLinks"] = "emailMagicLinks";
  Products["oauth"] = "oauth";
  Products["otp"] = "otp";
  Products["crypto"] = "crypto";
  Products["passwords"] = "passwords";
})(Products || (Products = {}));
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, and `Slack`.
 */


var OAuthProviders;

(function (OAuthProviders) {
  OAuthProviders["Google"] = "google";
  OAuthProviders["Microsoft"] = "microsoft";
  OAuthProviders["Apple"] = "apple";
  OAuthProviders["Github"] = "github";
  OAuthProviders["GitLab"] = "gitlab";
  OAuthProviders["Facebook"] = "facebook";
  OAuthProviders["Discord"] = "discord";
  OAuthProviders["Slack"] = "slack";
  OAuthProviders["Amazon"] = "amazon";
  OAuthProviders["Bitbucket"] = "bitbucket";
  OAuthProviders["LinkedIn"] = "linkedin";
  OAuthProviders["Coinbase"] = "coinbase";
  OAuthProviders["Twitch"] = "twitch";
})(OAuthProviders || (OAuthProviders = {}));
/**
 * The Crypto Wallets we support in our crypto product.
 * Currently we support all ethereum and solana wallets.
 * We additionally detect and show popular wallets as distinct options.
 * The list of poular wallets include `Binance`, `Coinbase`, `Metamask`, `Phantom`, and `Vessel`
 */


var Wallets;

(function (Wallets) {
  Wallets["Vessel"] = "Vessel";
  Wallets["Phantom"] = "Phantom";
  Wallets["Metamask"] = "Metamask";
  Wallets["Coinbase"] = "Coinbase";
  Wallets["Binance"] = "Binance";
  Wallets["GenericEthereumWallet"] = "Other Ethereum Wallet";
  Wallets["GenericSolanaWallet"] = "Other Solana Wallet";
})(Wallets || (Wallets = {}));
/**
 * For Google One Tap, we support two different position options:
 * `embedded` will display Google One Tap within the existing JavaScript SDK login form
 * `floating` will display the One Tap prompt in the top right corner.
 */


var OneTapPositions;

(function (OneTapPositions) {
  OneTapPositions["embedded"] = "embedded";
  OneTapPositions["floating"] = "floating";
})(OneTapPositions || (OneTapPositions = {}));
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */


var OTPMethods;

(function (OTPMethods) {
  OTPMethods["SMS"] = "sms";
  OTPMethods["WhatsApp"] = "whatsapp";
  OTPMethods["Email"] = "email";
})(OTPMethods || (OTPMethods = {}));

var StytchEventType;

(function (StytchEventType) {
  StytchEventType["MagicLinkLoginOrCreateEvent"] = "MAGIC_LINK_LOGIN_OR_CREATE";
  StytchEventType["OTPsLoginOrCreateEvent"] = "OTP_LOGIN_OR_CREATE";
  StytchEventType["OTPsAuthenticate"] = "OTP_AUTHENTICATE";
  StytchEventType["CryptoWalletAuthenticateStart"] = "CRYPTO_WALLET_AUTHENTICATE_START";
  StytchEventType["CryptoWalletAuthenticate"] = "CRYPTO_WALLET_AUTHENTICATE";
  StytchEventType["PasswordCreate"] = "PASSWORD_CREATE";
  StytchEventType["PasswordAuthenticate"] = "PASSWORD_AUTHENTICATE";
  StytchEventType["PasswordResetByEmailStart"] = "PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["PasswordResetByEmail"] = "PASSWORD_RESET_BY_EMAIL"; // More Events will go here ...
})(StytchEventType || (StytchEventType = {}));
/**
 * An Error class thrown when the SDK is unable to reach the Stytch servers,
 * or when the Stytch servers return a value the SDK cannot understand.
 * Usually - it means that you're offline!
 */


var SDKAPIUnreachableError = /*#__PURE__*/function (_Error) {
  _inherits(SDKAPIUnreachableError, _Error);

  var _super = _createSuper(SDKAPIUnreachableError);

  function SDKAPIUnreachableError(message, details) {
    var _this;

    _classCallCheck(this, SDKAPIUnreachableError);

    _this = _super.call(this, message + '\n' + details);
    _this.message = message + '\n' + details;
    _this.name = 'SDKAPIUnreachableError';
    _this.details = details;
    Object.setPrototypeOf(_assertThisInitialized(_this), SDKAPIUnreachableError.prototype);
    return _this;
  }

  return _createClass(SDKAPIUnreachableError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input fails client-side validation -
 * for example if a field that was expected to be a number is instead a string.
 */


var StytchSDKUsageError = /*#__PURE__*/function (_Error2) {
  _inherits(StytchSDKUsageError, _Error2);

  var _super2 = _createSuper(StytchSDKUsageError);

  function StytchSDKUsageError(methodName, message) {
    var _this2;

    _classCallCheck(this, StytchSDKUsageError);

    _this2 = _super2.call(this);
    _this2.name = 'StytchSDKUsageError';
    _this2.message = "Invalid call to ".concat(methodName, "\n") + message;
    return _this2;
  }

  return _createClass(StytchSDKUsageError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input does not adhere to the Stytch API schema -
 * for example if a field that was expected to be a number is instead a string.
 */


var StytchSDKSchemaError = /*#__PURE__*/function (_Error3) {
  _inherits(StytchSDKSchemaError, _Error3);

  var _super3 = _createSuper(StytchSDKSchemaError);

  function StytchSDKSchemaError(schemaError) {
    var _this3;

    _classCallCheck(this, StytchSDKSchemaError);

    var _a;

    _this3 = _super3.call(this);
    _this3.name = 'StytchSDKSchemaError';
    var messages = (_a = schemaError.body) === null || _a === void 0 ? void 0 : _a.map(function (err) {
      return "".concat(err.dataPath, ": ").concat(err.message);
    }).join('\n');
    _this3.message = "[400] Request does not match expected schema\n".concat(messages);
    return _this3;
  }

  return _createClass(StytchSDKSchemaError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class wrapping a well-formed JSON error from the Stytch API.
 * The Stytch error should match one listed at {@link https://stytch.com/docs/api/errors}
 */


var StytchSDKAPIError = /*#__PURE__*/function (_Error4) {
  _inherits(StytchSDKAPIError, _Error4);

  var _super4 = _createSuper(StytchSDKAPIError);

  function StytchSDKAPIError(details) {
    var _this4;

    _classCallCheck(this, StytchSDKAPIError);

    _this4 = _super4.call(this);
    _this4.name = 'StytchSDKAPIError';
    var status_code = details.status_code,
        error_type = details.error_type,
        error_message = details.error_message,
        error_url = details.error_url,
        request_id = details.request_id;
    _this4.error_type = error_type;
    _this4.error_message = error_message;
    _this4.error_url = error_url;
    _this4.request_id = request_id;
    _this4.status_code = status_code;
    _this4.message = "[".concat(status_code, "] ").concat(error_type, "\n") + "".concat(error_message, "\n") + "See ".concat(error_url, " for more information.\n") + ( // Web-Backend doesn't have request IDs yet, so if a request fails there it won't have one.
    // We should figure out how returning tracing info should work
    request_id ? "request_id: ".concat(request_id, "\n") : '');
    return _this4;
  }

  return _createClass(StytchSDKAPIError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Some errors are thrown from inside an iframe, but we can't serialize them
 * to the parent in Webkit. This class handles casting them to plain objects,
 * and restoring them on the other side. (ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®)
 * It preserves the error instance/class constructor by inspecting err.name
 * and calling `new` on the matching constructor.
 */


var ErrorMarshaller = /*#__PURE__*/function () {
  function ErrorMarshaller() {
    _classCallCheck(this, ErrorMarshaller);
  }

  _createClass(ErrorMarshaller, null, [{
    key: "marshall",
    value: function marshall(error) {
      return Object.assign(Object.assign({}, error), {
        // Some builtin errors don't have these as enumerable properties, need to specify manually
        name: error.name,
        message: error.message,
        stack: error.stack
      });
    }
  }, {
    key: "inflate",
    value: function inflate(ErrorClass, ErrorData) {
      // !!HACK!!
      // We make the assumption that if the error takes in a required property
      // (StytchSDKAPIError takes in an APIDetials obj...)
      // that we can just pass in the error body itself to satisfy the constructor...
      // And if the types don't work out, Object.assign(...) copies everything over anyway
      // This is a brittle and weak assumption.
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      var err = new ErrorClass(ErrorData);
      Object.assign(err, ErrorData);
      Object.setPrototypeOf(err, ErrorClass.prototype);
      return err;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(error) {
      if ('name' in error) {
        switch (error.name) {
          case 'SDKAPIUnreachableError':
            return ErrorMarshaller.inflate(SDKAPIUnreachableError, error);

          case 'StytchSDKSchemaError':
            return ErrorMarshaller.inflate(StytchSDKSchemaError, error);

          case 'StytchSDKAPIError':
            return ErrorMarshaller.inflate(StytchSDKAPIError, error);

          case 'TypeError':
            return ErrorMarshaller.inflate(TypeError, error);

          case 'SyntaxError':
            return ErrorMarshaller.inflate(SyntaxError, error);

          case 'ReferenceError':
            return ErrorMarshaller.inflate(ReferenceError, error);

          case 'RangeError':
            return ErrorMarshaller.inflate(RangeError, error);

          case 'EvalError':
            return ErrorMarshaller.inflate(EvalError, error);

          case 'URIError':
            return ErrorMarshaller.inflate(URIError, error);
        }
      }

      return ErrorMarshaller.inflate(Error, error);
    }
  }]);

  return ErrorMarshaller;
}();
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */


function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

var IframeHostClient = /*#__PURE__*/function () {
  function IframeHostClient(iframeURL) {
    _classCallCheck(this, IframeHostClient);

    this.iframeURL = iframeURL;
    this.createIframe();
  }

  _createClass(IframeHostClient, [{
    key: "createIframe",
    value: function createIframe() {
      var existingIframe = document.querySelector("[src~=\"".concat(this.iframeURL, "\"]"));
      /* If an iframe does not exist yet, create one */

      if (!existingIframe) {
        existingIframe = document.createElement('iframe');
        existingIframe.src = this.iframeURL;
        existingIframe.style.position = 'absolute';
        existingIframe.style.width = '0';
        existingIframe.style.height = '0';
        existingIframe.style.border = '0';
        document.body.appendChild(existingIframe);
      } else {
        logger.warn("It looks like you're creating multiple copies of the Stytch client." + ' This behavior is unsupported, and unintended side effects may occur. ' + "Make sure you are creating the Stytch client at the global level, and not inside a component's render function.");
      }
      /**
       * [NASTY BUG]
       * If we postMessage to an iframe that is _not yet loaded_, chrome will give a cryptic error message
       * Failed to execute 'postMessage' on 'DOMWindow':
       *   The target origin provided ('https://js.stytch.com') does not match the recipient window's origin ('http://localhost:3000').
       * There is no builtin way to determine if an iframe is already loaded,
       * so we set a dataset attr in our onload handler and use that to determine loading state
       */


      if (existingIframe.dataset.loaded === 'true') {
        this.frame = Promise.resolve(existingIframe);
        return;
      }

      this.frame = new Promise(function (resolve) {
        existingIframe.addEventListener('load', function () {
          existingIframe.dataset.loaded = 'true';
          resolve(existingIframe);
        }, {
          once: true
        });
      });
    }
  }, {
    key: "call",
    value: function call(method, args) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this5 = this;

        var frame, channel;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.frame;

              case 2:
                frame = _context.sent;
                channel = new MessageChannel();
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  var _a;

                  channel.port1.onmessage = function (event) {
                    var resp = event.data;
                    channel.port1.close();

                    if (resp.success) {
                      resolve(resp.payload);
                    } else {
                      reject(ErrorMarshaller.unmarshall(resp.error));
                    }
                  };

                  var message = {
                    method: method,
                    args: args
                  };
                  (_a = frame.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, _this5.iframeURL, [channel.port2]);
                }));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }
  }]);

  return IframeHostClient;
}();

var IframeEmbeddedClient = /*#__PURE__*/function () {
  function IframeEmbeddedClient() {
    var _this6 = this;

    _classCallCheck(this, IframeEmbeddedClient);

    this.handlers = {};
    window.addEventListener('message', function (event) {
      _this6.runHandler(event);
    });
  }

  _createClass(IframeEmbeddedClient, [{
    key: "runHandler",
    value: function runHandler(event) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var req, port, handler, payload;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                req = event.data;
                port = event.ports[0];
                handler = this.handlers[req.method];

                if (!(!handler || !port)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return");

              case 5:
                _context2.prev = 5;
                _context2.next = 8;
                return handler.apply(void 0, _toConsumableArray(req.args));

              case 8:
                payload = _context2.sent;
                port.postMessage({
                  success: true,
                  payload: payload
                });
                _context2.next = 15;
                break;

              case 12:
                _context2.prev = 12;
                _context2.t0 = _context2["catch"](5);
                port.postMessage({
                  success: false,
                  error: ErrorMarshaller.marshall(_context2.t0)
                });

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 12]]);
      }));
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "registerHandler",
    value: function registerHandler(handler, handlerImpl) {
      this.handlers[handler] = handlerImpl;
    }
  }]);

  return IframeEmbeddedClient;
}(); // Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).


var getRandomValues;
var rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate$1(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */


var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate$1(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

var ModulePromiseCache = {};

function loadESModule(url, moduleFromGlobalScope) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(ModulePromiseCache[url] !== undefined)) {
              _context3.next = 2;
              break;
            }

            return _context3.abrupt("return", ModulePromiseCache[url]);

          case 2:
            ModulePromiseCache[url] = loadESModuleFromNetwork(url, moduleFromGlobalScope);
            return _context3.abrupt("return", ModulePromiseCache[url]);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
}

function loadESModuleFromNetwork(url, moduleFromGlobalScope) {
  return new Promise(function (resolve, reject) {
    var maybeScript = findScript(url);

    if (maybeScript && maybeScript.dataset.loaded === 'true') {
      try {
        resolve(moduleFromGlobalScope());
      } catch (err) {
        return reject(new Error("".concat(url, " already loaded, but module was not found in global scope: ").concat(err)));
      }
    }

    var script = createScript(url);
    script.addEventListener('load', function () {
      script.dataset.loaded = 'true';

      try {
        resolve(moduleFromGlobalScope());
      } catch (err) {
        reject(new Error("".concat(url, " was loaded, but module was not found in global scope: ").concat(err)));
      }
    });
    script.addEventListener('error', function (err) {
      reject(new Error("".concat(url, " could not be loaded: ").concat(err)));
    });
  });
}

var findScriptsInDom = function findScriptsInDom(url) {
  return document.querySelectorAll("script[src=\"".concat(url, "\"]"));
};

function findScript(url) {
  var scripts = findScriptsInDom(url);

  if (scripts[0]) {
    return scripts[0];
  }
}

function createScript(url) {
  var script = document.createElement('script');
  script.setAttribute('src', url);
  script.setAttribute('async', 'true');
  script.setAttribute('defer', 'true');
  document.head.appendChild(script);
  return script;
}
/**
 * A set of tokens to stylize the console.log output
 * First token is the raw text. %c is a placeholder for string formatting
 * Second token starts our stylizing - adding custom color and background
 * Third token resets stylizing to baseline before showing the rest of the content.
 */


var STYTCH_BADGE = process.env.NODE_ENV === 'production' ? ['[Stytch]'] : ['%c[Stytch]%c', 'background: #19303d; color: #13E5C0; padding: 2px;border-radius: 4px', '']; // Turn this to true to enable debug logs
// TODO: Make this an env var

var DEBUG = false;
/* eslint-disable no-console */

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * An ultralightweight wrapper around console.log.
 * In the future, the logger might be passed in from the customer,
 * or the level might be configurable.
 */

var logger = {
  debug: function debug() {
    return DEBUG;
  },
  log: function log() {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).log.apply(_console, STYTCH_BADGE.concat(args));
  },
  warn: function warn() {
    var _console2;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return (_console2 = console).warn.apply(_console2, STYTCH_BADGE.concat(args));
  },
  error: function error() {
    var _console3;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return (_console3 = console).error.apply(_console3, STYTCH_BADGE.concat(args));
  }
};
/* eslint-enable @typescript-eslint/no-explicit-any */

/* eslint-enable no-console */

var trailer = "\nYou can find your public token at https://stytch.com/dashboard/api-keys.";

var checkPublicToken = function checkPublicToken(publicToken) {
  if (typeof publicToken !== 'string') {
    logger.warn("Public token is malformed. Expected a string, got ".concat(_typeof(publicToken), ".").concat(trailer));
  } else if (publicToken === '') {
    logger.warn("Public token is malformed. Expected \"public-token-...\", got an empty string.".concat(trailer));
  } else if (!publicToken.startsWith('public-token-')) {
    logger.warn("Public token is malformed. Expected \"public-token-...\", got ".concat(publicToken, ".").concat(trailer));
  }
};

var checkNotSSR = function checkNotSSR(clientName) {
  var codeSample = clientName === 'StytchUIClient' ? "import { createStytchUIClient } from '@stytch/nextjs/ui';\n    \nconst stytch = createStytchUIClient('public-token-...');\n" : "import { createStytchHeadlessClient } from '@stytch/nextjs/ui';\n    \nconst stytch = createStytchHeadlessClient('public-token-...');\n";

  if (typeof window === 'undefined') {
    throw new Error("The ".concat(clientName, " is not compatible with server-side environments.\nIf using nextjs, use the create").concat(clientName, " method instead.\n```\n").concat(codeSample, "\n```\n"));
  }
};

var isTestPublicToken = function isTestPublicToken(token) {
  return token.includes('public-token-test');
};

var createDeepEqual = function createDeepEqual() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$KEYS_TO_EXCLUDE = _ref.KEYS_TO_EXCLUDE,
      KEYS_TO_EXCLUDE = _ref$KEYS_TO_EXCLUDE === void 0 ? [] : _ref$KEYS_TO_EXCLUDE;

  // If comparing functions, this may need some work. Not sure the
  // best path for this: compare instance (what it currently does),
  // stringify and compare, etc.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var deepEqual = function deepEqual(a, b) {
    // Ensures type is the same
    if (_typeof(a) !== _typeof(b)) return false; // arrays, null, and objects all have type 'object'

    if (a === null || b === null) return a === b;

    if (_typeof(a) === 'object') {
      if (Object.keys(a).length !== Object.keys(b).length || Object.keys(a).some(function (k) {
        return !(k in b);
      })) return false;
      return Object.entries(a).filter(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 1),
            k = _ref3[0];

        return !KEYS_TO_EXCLUDE.includes(k);
      }).every(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
            k = _ref5[0],
            v = _ref5[1];

        return deepEqual(v, b[k]);
      });
    } // boolean, string, number, undefined


    return a === b;
  };

  return deepEqual;
};
/**
 * Normalizes an es5 promise with a .then(onSuccess, onFailure) signature to
 * the es6 .then().catch() signature
 */


var normalizePromiseLike = function normalizePromiseLike(prom) {
  return new Promise(function (resolve, reject) {
    prom.then(resolve, reject);
  });
};

var createEventId = function createEventId() {
  return "event-id-".concat(v4());
};

var createAppSessionId = function createAppSessionId() {
  return "app-session-id-".concat(v4());
};

var createPersistentId = function createPersistentId() {
  return "persistent-id-".concat(v4());
};

var validate = function validate(methodName) {
  var validator = {
    isString: function isString(fieldName, value) {
      if (typeof value !== 'string') {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be a string.');
      }

      return validator;
    },
    isOptionalString: function isOptionalString(fieldName, value) {
      if (typeof value === 'undefined') {
        return validator;
      }

      return validator.isString(fieldName, value);
    },
    isStringArray: function isStringArray(fieldName, value) {
      if (!Array.isArray(value)) {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be an array of strings.');
      }

      var _iterator = _createForOfIteratorHelper(value),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var str = _step.value;

          if (typeof str !== 'string') {
            throw new StytchSDKUsageError(methodName, fieldName + ' must be an array of strings.');
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return validator;
    },
    isNumber: function isNumber(fieldName, value) {
      if (typeof value !== 'number') {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be a number.');
      }

      return validator;
    },
    isOptionalNumber: function isOptionalNumber(fieldName, value) {
      if (typeof value === 'undefined') {
        return validator;
      }

      return validator.isNumber(fieldName, value);
    }
  };
  return validator;
};

var isPhoneMethod = function isPhoneMethod(selectionMethod) {
  return selectionMethod === OTPMethods.SMS || selectionMethod === OTPMethods.WhatsApp;
};

var isEmailMethod = function isEmailMethod(selectionMethod) {
  return selectionMethod === OTPMethods.Email;
};

var removeResponseCommon = function removeResponseCommon(_a) {
  var rest = __rest(_a, ["request_id", "status_code"]);

  return rest;
};

var omitUser = function omitUser(resp) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  var rest = __rest(resp, ["__user"]);

  return rest;
};

function baseFetchSDK(_ref6) {
  var method = _ref6.method,
      errorMessage = _ref6.errorMessage,
      finalURL = _ref6.finalURL,
      basicAuthHeader = _ref6.basicAuthHeader,
      xSDKClientHeader = _ref6.xSDKClientHeader,
      xSDKParentHostHeader = _ref6.xSDKParentHostHeader,
      body = _ref6.body;
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    var headers, fetchOpts, resp, respError, respData;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            headers = {
              Authorization: basicAuthHeader,
              'Content-Type': 'application/json',
              'X-SDK-Client': xSDKClientHeader
            };

            if (xSDKParentHostHeader) {
              headers['X-SDK-Parent-Host'] = xSDKParentHostHeader;
            }

            fetchOpts = {
              method: method,
              headers: headers,
              body: body && JSON.stringify(body)
            };
            _context4.prev = 3;
            _context4.next = 6;
            return fetch(finalURL, fetchOpts);

          case 6:
            resp = _context4.sent;
            _context4.next = 14;
            break;

          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](3);

            if (!(_context4.t0.message === 'Failed to fetch')) {
              _context4.next = 13;
              break;
            }

            throw new SDKAPIUnreachableError(errorMessage, 'Unable to contact the Stytch servers. Are you online?');

          case 13:
            throw _context4.t0;

          case 14:
            if (!(resp.status !== 200)) {
              _context4.next = 27;
              break;
            }

            _context4.prev = 15;
            _context4.next = 18;
            return resp.json();

          case 18:
            respError = _context4.sent;
            _context4.next = 24;
            break;

          case 21:
            _context4.prev = 21;
            _context4.t1 = _context4["catch"](15);
            throw new SDKAPIUnreachableError(errorMessage, 'Invalid or no response from server');

          case 24:
            if (!('body' in respError || 'params' in respError || 'query' in respError)) {
              _context4.next = 26;
              break;
            }

            throw new StytchSDKSchemaError(respError);

          case 26:
            throw new StytchSDKAPIError(respError);

          case 27:
            _context4.prev = 27;
            _context4.next = 30;
            return resp.json();

          case 30:
            respData = _context4.sent;
            return _context4.abrupt("return", respData.data);

          case 34:
            _context4.prev = 34;
            _context4.t2 = _context4["catch"](27);
            throw new SDKAPIUnreachableError(errorMessage, 'Invalid response from the Stytch servers.');

          case 37:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 9], [15, 21], [27, 34]]);
  }));
}

var SessionManager = /*#__PURE__*/function () {
  function SessionManager(_subscriptionService, _headlessSessionClient) {
    var _this7 = this;

    _classCallCheck(this, SessionManager);

    this._subscriptionService = _subscriptionService;
    this._headlessSessionClient = _headlessSessionClient;
    /**
     * We need to listen to a few types of events:
     * - If the user logs in via invoking a .authenticate() call, we should start the background worker
     * - If the user steps up their authentication via another .authenticate call(), we should restart the background worker
     * - If the user logs out, we should terminate the worker
     * - We should ignore session changes that we ourselves caused - so if we already have a timeout, leave it be!
     */

    this._onSessionChange = function (sess) {
      if (sess) {
        _this7.scheduleBackgroundRefresh();
      } else {
        _this7.cancelBackgroundRefresh();
      }
    };

    this._reauthenticateWithBackoff = function () {
      var retryIfPossible = function retryIfPossible(count) {
        return function (err) {
          if (SessionManager.isUnrecoverableRecoverableError(err)) {
            return Promise.reject(err);
          }

          return new Promise(function (done) {
            return setTimeout(done, SessionManager.timeoutForAttempt(count));
          }).then(function () {
            return _this7._headlessSessionClient.authenticate();
          });
        };
      };

      return _this7._headlessSessionClient.authenticate()["catch"](retryIfPossible(0)) // 2000ms delay
      ["catch"](retryIfPossible(1)) // 4000ms delay
      ["catch"](retryIfPossible(2)) // 8000ms delay
      ["catch"](retryIfPossible(3)) // 16000ms delay
      ["catch"](retryIfPossible(4)); // 32000ms delay
    };

    this.timeout = null;

    this._subscriptionService.subscribeToSession(this._onSessionChange);
  }
  /**
   * The core logic of the session refresh recursive trampoline
   * - Refreshes the currently issued session
   * - Schedules a future refresh if successful
   */


  _createClass(SessionManager, [{
    key: "performBackgroundRefresh",
    value: function performBackgroundRefresh() {
      var _this8 = this;

      logger.debug('performing background refresh at ', Date.now());

      this._reauthenticateWithBackoff().then(function () {
        _this8.scheduleBackgroundRefresh();
      })["catch"](function () {
        logger.warn('Session background refresh failed. Signalling to app that user is logged out.');

        _this8._subscriptionService.destroyState();
      });
    }
  }, {
    key: "scheduleBackgroundRefresh",
    value: function scheduleBackgroundRefresh() {
      var _this9 = this;

      /* Highlander rules - there can only ever be one */
      this.cancelBackgroundRefresh();
      logger.debug('Scheduling bg refresh', Date.now());
      this.timeout = setTimeout(function () {
        _this9.performBackgroundRefresh();
      }, SessionManager.REFRESH_INTERVAL_MS);
    }
  }, {
    key: "cancelBackgroundRefresh",
    value: function cancelBackgroundRefresh() {
      if (this.timeout !== null) {
        logger.debug('Cancelling bg refresh', Date.now());
        clearTimeout(this.timeout);
        this.timeout = null;
      }
    } // We start with a backoff of 2000ms and increase exponentially to 32000ms (+/- 175 ms for jitter)
    // Total time waiting should be ~62000ms
    // These numbers were picked pretty arbitrarily, but they satisfy the constraint
    // that sum(timeouts) should be well under 2 minutes
    // so we can run all the attempts before the 5m JWT expiration
    // allocating ~50s for p9999 network latency across 4 retries

  }], [{
    key: "timeoutForAttempt",
    value: function timeoutForAttempt(count) {
      var jitter = Math.floor(Math.random() * 350) - 175;
      var delayMS = 2000 * Math.pow(2, count);
      return jitter + delayMS;
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "isUnrecoverableRecoverableError",
    value: function isUnrecoverableRecoverableError(error) {
      return error.error_type === 'unauthorized_credentials' || error.error_type === 'user_unauthenticated';
    }
  }]);

  return SessionManager;
}(); // Three minutes


SessionManager.REFRESH_INTERVAL_MS = 1000 * 60 * 3;
var LOCAL_STORAGE_KEY_PREFIX = 'stytch_sdk_state_';

var getLocalStorageKey = function getLocalStorageKey(publicToken) {
  return "".concat(LOCAL_STORAGE_KEY_PREFIX).concat(publicToken);
};

var SubscriptionDataLayer = /*#__PURE__*/function () {
  function SubscriptionDataLayer(_publicToken, _storageClient, _networkClient) {
    var _this10 = this;

    _classCallCheck(this, SubscriptionDataLayer);

    this._publicToken = _publicToken;
    this._storageClient = _storageClient;
    this._networkClient = _networkClient;

    this.syncFromLocalStorage = function () {
      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this11 = this;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this._storageClient.getData(getLocalStorageKey(this._publicToken)).then(function (data) {
                  if (!data) {
                    return null;
                  }

                  var parsedState;

                  try {
                    parsedState = JSON.parse(data);
                  } catch (e) {
                    // Overwrite the bad data
                    _this11._storageClient.clearData(getLocalStorageKey(_this11._publicToken)); // this.removeSessionCookie();


                    return null;
                  }

                  var _parsedState = parsedState,
                      session = _parsedState.session,
                      user = _parsedState.user,
                      session_token = _parsedState.session_token,
                      session_jwt = _parsedState.session_jwt;
                  _this11.session = session;
                  _this11.user = user;
                  _this11.session_token = session_token;
                  _this11.session_jwt = session_jwt;
                  return {
                    session: session,
                    user: user,
                    session_token: session_token,
                    session_jwt: session_jwt
                  };
                })["catch"](function () {
                  return null;
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
    };

    this.session = null;
    this.user = null;
    this.session_token = null;
    this.session_jwt = null;
    this.sessionSubscriptions = {};
    this.userSubscriptions = {};
  }

  _createClass(SubscriptionDataLayer, [{
    key: "syncToLocalStorage",
    value: function syncToLocalStorage() {
      this._storageClient.setData(getLocalStorageKey(this._publicToken), JSON.stringify({
        session: this.session,
        user: this.user,
        session_token: this.session_token,
        session_jwt: this.session_jwt
      }));
    }
  }]);

  return SubscriptionDataLayer;
}();

var addSubscriber = function addSubscriber(collection, subscriber) {
  var uniqueId = Math.random().toString(36).slice(-10);
  collection[uniqueId] = subscriber;
  return function () {
    return delete collection[uniqueId];
  };
};

var notifySubscribers = function notifySubscribers(collection, value) {
  Object.values(collection).forEach(function (cb) {
    return cb(value);
  });
};

var SubscriptionService = /*#__PURE__*/function () {
  function SubscriptionService(publicToken, storageClient, _networkClient) {
    _classCallCheck(this, SubscriptionService);

    this._networkClient = _networkClient; // TODO: Generalize this for Mobile and Web based SDKs

    this._datalayer = new SubscriptionDataLayer(publicToken, storageClient, _networkClient);
    var session = this._datalayer.session;

    if (session && Date.parse(session.expires_at) < Date.now()) {
      this.destroyState();
      return;
    }
  }

  _createClass(SubscriptionService, [{
    key: "syncFromDeviceStorage",
    value: function syncFromDeviceStorage(onCompleteCallback) {
      var _this12 = this;

      this._datalayer.syncFromLocalStorage().then(function (res) {
        if (!res) {
          return;
        } else if (res.session && Date.parse(res.session.expires_at) < Date.now()) {
          _this12.destroyState();

          return;
        } else {
          _this12.updateState(res);
        }
      });

      onCompleteCallback();
    }
  }, {
    key: "getSession",
    value: function getSession() {
      return this._datalayer.session;
    }
  }, {
    key: "getTokens",
    value: function getTokens() {
      if (!this._datalayer.session_token || !this._datalayer.session_jwt) {
        return null;
      }

      return {
        session_token: this._datalayer.session_token,
        session_jwt: this._datalayer.session_jwt
      };
    }
  }, {
    key: "destroyState",
    value: function destroyState() {
      this.updateState({
        session: null,
        user: null,
        session_token: null,
        session_jwt: null
      });
    }
  }, {
    key: "_updateStateInternal",
    value: function _updateStateInternal(stateDiff) {
      var session = stateDiff.session,
          user = stateDiff.user,
          session_token = stateDiff.session_token,
          session_jwt = stateDiff.session_jwt;
      this._datalayer.session = session;
      this._datalayer.user = user;
      this._datalayer.session_token = session_token;
      this._datalayer.session_jwt = session_jwt;
      notifySubscribers(this._datalayer.sessionSubscriptions, session);
      notifySubscribers(this._datalayer.userSubscriptions, user);
    }
  }, {
    key: "updateState",
    value: function updateState(stateDiff) {
      this._updateStateInternal(stateDiff);

      this._networkClient.updateSessionToken(stateDiff.session_token);

      this._datalayer.syncToLocalStorage();
    }
  }, {
    key: "updateUser",
    value: function updateUser(user) {
      this._datalayer.user = user;
      notifySubscribers(this._datalayer.userSubscriptions, user); // Delay notifying other tabs until after we have refreshed ourselves

      this._datalayer.syncToLocalStorage();
    }
  }, {
    key: "subscribeToSession",
    value: function subscribeToSession(callback) {
      return addSubscriber(this._datalayer.sessionSubscriptions, callback);
    }
  }, {
    key: "getUser",
    value: function getUser() {
      return this._datalayer.user;
    }
  }, {
    key: "subscribeToUser",
    value: function subscribeToUser(callback) {
      return addSubscriber(this._datalayer.userSubscriptions, callback);
    }
  }]);

  return SubscriptionService;
}();

var DEFAULT_MAX_BATCH_SIZE = 15;
var DEFAULT_INTERVAL_DURATION_MS = 800;

var EventLogger = /*#__PURE__*/function () {
  function EventLogger(args) {
    _classCallCheck(this, EventLogger);

    this.maxBatchSize = args.maxBatchSize;
    this.logEventURL = args.logEventURL; // TODO: If we create more than one of these, we'll want a mechanism to clean up the intervals

    setInterval(this.flush.bind(this), args.intervalDurationMs);
    this.batch = [];
  }

  _createClass(EventLogger, [{
    key: "logEvent",
    value: function logEvent(telemetry, event) {
      this.batch.push({
        telemetry: telemetry,
        event: event
      });

      if (this.batch.length >= this.maxBatchSize) {
        this.flush();
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var batchToSubmit;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this.batch.length) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                batchToSubmit = this.batch;
                this.batch = [];
                _context6.prev = 4;
                _context6.next = 7;
                return fetch(this.logEventURL, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(batchToSubmit)
                });

              case 7:
                _context6.next = 11;
                break;

              case 9:
                _context6.prev = 9;
                _context6.t0 = _context6["catch"](4);

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[4, 9]]);
      }));
    }
  }]);

  return EventLogger;
}();

var HeadlessUserClient = /*#__PURE__*/_createClass(function HeadlessUserClient(_networkClient, _subscriptionService) {
  var _this13 = this;

  _classCallCheck(this, HeadlessUserClient);

  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;

  this.get = function () {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this._networkClient.fetchSDK({
                url: '/users/me',
                errorMessage: 'Failed to retrieve user info.',
                method: 'GET'
              });

            case 2:
              resp = _context7.sent;
              user = removeResponseCommon(resp);

              this._subscriptionService.updateUser(user);

              return _context7.abrupt("return", user);

            case 6:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));
  };

  this.getSync = function () {
    return _this13._subscriptionService.getUser();
  };

  this.update = function (options) {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this._networkClient.fetchSDK({
                url: '/users/me',
                body: options,
                errorMessage: 'Failed to update user.',
                method: 'PUT'
              });

            case 2:
              resp = _context8.sent;
              user = removeResponseCommon(resp.__user);

              this._subscriptionService.updateUser(user);

              return _context8.abrupt("return", omitUser(resp));

            case 6:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));
  };

  this.deleteEmail = function (emailId) {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this._networkClient.fetchSDK({
                url: "/users/emails/".concat(emailId),
                errorMessage: 'Failed to delete email.',
                method: 'DELETE'
              });

            case 2:
              resp = _context9.sent;
              user = removeResponseCommon(resp.__user);

              this._subscriptionService.updateUser(user);

              return _context9.abrupt("return", omitUser(resp));

            case 6:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));
  };

  this.deletePhoneNumber = function (phoneId) {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this._networkClient.fetchSDK({
                url: "/users/phone_numbers/".concat(phoneId),
                errorMessage: 'Failed to delete phone number.',
                method: 'DELETE'
              });

            case 2:
              resp = _context10.sent;
              user = removeResponseCommon(resp.__user);

              this._subscriptionService.updateUser(user);

              return _context10.abrupt("return", omitUser(resp));

            case 6:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));
  };

  this.deleteTOTP = function (totpId) {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this._networkClient.fetchSDK({
                url: "/users/totps/".concat(totpId),
                errorMessage: 'Failed to delete TOTP.',
                method: 'DELETE'
              });

            case 2:
              resp = _context11.sent;
              user = removeResponseCommon(resp.__user);

              this._subscriptionService.updateUser(user);

              return _context11.abrupt("return", omitUser(resp));

            case 6:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));
  };

  this.deleteWebauthnRegistration = function (webAuthnId) {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this._networkClient.fetchSDK({
                url: "/users/webauthn_registrations/".concat(webAuthnId),
                errorMessage: 'Failed to delete WebAuthn registration.',
                method: 'DELETE'
              });

            case 2:
              resp = _context12.sent;
              user = removeResponseCommon(resp.__user);

              this._subscriptionService.updateUser(user);

              return _context12.abrupt("return", omitUser(resp));

            case 6:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));
  };

  this.onChange = function (callback) {
    return _this13._subscriptionService.subscribeToUser(callback);
  };
});

var HeadlessSessionClient = /*#__PURE__*/function () {
  function HeadlessSessionClient(_networkClient, _subscriptionService) {
    var _this14 = this;

    _classCallCheck(this, HeadlessSessionClient);

    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;

    this.getSync = function () {
      return _this14._subscriptionService.getSession();
    };

    this.onChange = function (callback) {
      return _this14._subscriptionService.subscribeToSession(callback);
    };

    this.revoke = function () {
      return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._networkClient.fetchSDK({
                  url: "/sessions/revoke",
                  errorMessage: 'Error revoking session',
                  method: 'POST'
                });

              case 2:
                resp = _context13.sent;

                // TODO: Can destroyState throw? Why do we need to catch here?
                try {
                  this._subscriptionService.destroyState();
                } catch (_a) {}

                return _context13.abrupt("return", resp);

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));
    };

    this.authenticate = function (options) {
      return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.prev = 0;
                requestBody = {
                  session_duration_minutes: options === null || options === void 0 ? void 0 : options.session_duration_minutes
                };
                _context14.next = 4;
                return this._networkClient.fetchSDK({
                  url: '/sessions/authenticate',
                  body: requestBody,
                  errorMessage: 'Error authenticating session',
                  method: 'POST'
                });

              case 4:
                resp = _context14.sent;

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: resp.user,
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context14.abrupt("return", omitUser(resp));

              case 9:
                _context14.prev = 9;
                _context14.t0 = _context14["catch"](0);

                this._subscriptionService.destroyState();

                throw _context14.t0;

              case 13:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[0, 9]]);
      }));
    };
  }

  _createClass(HeadlessSessionClient, [{
    key: "getTokens",
    value: function getTokens() {
      return this._subscriptionService.getTokens();
    }
  }]);

  return HeadlessSessionClient;
}();

var DefaultDynamicConfig$1 = Promise.resolve({
  pkceRequiredForEmailMagicLinks: false
});

var HeadlessMagicLinksClient = /*#__PURE__*/function () {
  function HeadlessMagicLinksClient(_networkClient, _subscriptionService, _pkceManager) {
    var _this15 = this;

    var _config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultDynamicConfig$1;

    var executeRecaptcha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
      return Promise.resolve(undefined);
    };

    _classCallCheck(this, HeadlessMagicLinksClient);

    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._config = _config;
    this.executeRecaptcha = executeRecaptcha;
    this.email = {
      loginOrCreate: function loginOrCreate(email) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
          var _yield$this$_config, pkceRequiredForEmailMagicLinks, code_challenge, requestBody;

          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  _context15.next = 2;
                  return this._config;

                case 2:
                  _yield$this$_config = _context15.sent;
                  pkceRequiredForEmailMagicLinks = _yield$this$_config.pkceRequiredForEmailMagicLinks;
                  code_challenge = undefined;

                  if (!pkceRequiredForEmailMagicLinks) {
                    _context15.next = 9;
                    break;
                  }

                  _context15.next = 8;
                  return this.getCodeChallenge();

                case 8:
                  code_challenge = _context15.sent;

                case 9:
                  _context15.t0 = Object;
                  _context15.t1 = Object.assign({}, options);
                  _context15.t2 = email;
                  _context15.t3 = code_challenge;
                  _context15.next = 15;
                  return this.executeRecaptcha();

                case 15:
                  _context15.t4 = _context15.sent;
                  _context15.t5 = {
                    email: _context15.t2,
                    code_challenge: _context15.t3,
                    captcha_token: _context15.t4
                  };
                  requestBody = _context15.t0.assign.call(_context15.t0, _context15.t1, _context15.t5);
                  return _context15.abrupt("return", this._networkClient.fetchSDK({
                    url: '/magic_links/email/login_or_create',
                    body: requestBody,
                    errorMessage: 'Failed to send magic link',
                    method: 'POST'
                  }));

                case 19:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15, this);
        }));
      },
      send: function send(email) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
          var _yield$this$_config2, pkceRequiredForEmailMagicLinks, code_challenge, requestBody, isLoggedIn, endpoint;

          return _regeneratorRuntime().wrap(function _callee16$(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  _context16.next = 2;
                  return this._config;

                case 2:
                  _yield$this$_config2 = _context16.sent;
                  pkceRequiredForEmailMagicLinks = _yield$this$_config2.pkceRequiredForEmailMagicLinks;
                  code_challenge = undefined;

                  if (!pkceRequiredForEmailMagicLinks) {
                    _context16.next = 9;
                    break;
                  }

                  _context16.next = 8;
                  return this.getCodeChallenge();

                case 8:
                  code_challenge = _context16.sent;

                case 9:
                  _context16.t0 = Object;
                  _context16.t1 = Object.assign({}, options);
                  _context16.t2 = email;
                  _context16.t3 = code_challenge;
                  _context16.next = 15;
                  return this.executeRecaptcha();

                case 15:
                  _context16.t4 = _context16.sent;
                  _context16.t5 = {
                    email: _context16.t2,
                    code_challenge: _context16.t3,
                    captcha_token: _context16.t4
                  };
                  requestBody = _context16.t0.assign.call(_context16.t0, _context16.t1, _context16.t5);
                  isLoggedIn = !!this._subscriptionService.getSession();
                  endpoint = isLoggedIn ? '/magic_links/email/send/secondary' : '/magic_links/email/send/primary';
                  return _context16.abrupt("return", this._networkClient.fetchSDK({
                    url: endpoint,
                    body: requestBody,
                    errorMessage: 'Failed to send magic link',
                    method: 'POST'
                  }));

                case 21:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee16, this);
        }));
      }
    };

    this.authenticate = function (token, options) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var _a, requestBody, resp;

        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                validate('stytch.magicLinks.authenticate').isString('Token', token).isNumber('session_duration_minutes', options.session_duration_minutes);
                requestBody = Object.assign({
                  token: token,
                  code_verifier: (_a = this._pkceManager.getPKPair()) === null || _a === void 0 ? void 0 : _a.code_verifier
                }, options);
                _context17.next = 4;
                return this._networkClient.fetchSDK({
                  url: '/magic_links/authenticate',
                  body: requestBody,
                  errorMessage: 'Failed to authenticate token.',
                  method: 'POST'
                });

              case 4:
                resp = _context17.sent;

                this._pkceManager.clearPKPair();

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: resp.user,
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context17.abrupt("return", omitUser(resp));

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));
    };
  }

  _createClass(HeadlessMagicLinksClient, [{
    key: "getCodeChallenge",
    value: function getCodeChallenge() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        var keyPair;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                keyPair = this._pkceManager.getPKPair();

                if (!keyPair) {
                  _context18.next = 3;
                  break;
                }

                return _context18.abrupt("return", keyPair.code_challenge);

              case 3:
                _context18.next = 5;
                return this._pkceManager.startPKCETransaction();

              case 5:
                keyPair = _context18.sent;
                return _context18.abrupt("return", keyPair.code_challenge);

              case 7:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));
    }
  }]);

  return HeadlessMagicLinksClient;
}();

var HeadlessOTPClient = /*#__PURE__*/_createClass(function HeadlessOTPClient(_networkClient, _subscriptionService) {
  var _this16 = this;

  var executeRecaptcha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
    return Promise.resolve(undefined);
  };

  _classCallCheck(this, HeadlessOTPClient);

  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;
  this.executeRecaptcha = executeRecaptcha;
  this.sms = {
    loginOrCreate: function loginOrCreate(phone_number, options) {
      return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        var captcha_token, requestBody;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.executeRecaptcha();

              case 2:
                captcha_token = _context19.sent;
                requestBody = Object.assign(Object.assign({}, options), {
                  phone_number: phone_number,
                  captcha_token: captcha_token
                });
                return _context19.abrupt("return", this._networkClient.fetchSDK({
                  url: '/otps/sms/login_or_create',
                  body: requestBody,
                  errorMessage: 'Failed to send one time passcode',
                  method: 'POST'
                }));

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));
    },
    send: function send(phone_number, options) {
      return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        var captcha_token, requestBody, isLoggedIn, endpoint;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.executeRecaptcha();

              case 2:
                captcha_token = _context20.sent;
                requestBody = Object.assign(Object.assign({}, options), {
                  phone_number: phone_number,
                  captcha_token: captcha_token
                });
                isLoggedIn = !!this._subscriptionService.getSession();
                endpoint = isLoggedIn ? '/otps/sms/send/secondary' : '/otps/sms/send/primary';
                return _context20.abrupt("return", this._networkClient.fetchSDK({
                  url: endpoint,
                  body: requestBody,
                  errorMessage: 'Failed to send one time passcode',
                  method: 'POST'
                }));

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));
    }
  };
  this.whatsapp = {
    loginOrCreate: function loginOrCreate(phone_number, options) {
      return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
        var captcha_token, requestBody;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.executeRecaptcha();

              case 2:
                captcha_token = _context21.sent;
                requestBody = Object.assign(Object.assign({}, options), {
                  phone_number: phone_number,
                  captcha_token: captcha_token
                });
                return _context21.abrupt("return", this._networkClient.fetchSDK({
                  url: '/otps/whatsapp/login_or_create',
                  body: requestBody,
                  errorMessage: 'Failed to send one time passcode',
                  method: 'POST'
                }));

              case 5:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));
    },
    send: function send(phone_number, options) {
      return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        var captcha_token, requestBody, isLoggedIn, endpoint;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.executeRecaptcha();

              case 2:
                captcha_token = _context22.sent;
                requestBody = Object.assign(Object.assign({}, options), {
                  phone_number: phone_number,
                  captcha_token: captcha_token
                });
                isLoggedIn = !!this._subscriptionService.getSession();
                endpoint = isLoggedIn ? '/otps/whatsapp/send/secondary' : '/otps/whatsapp/send/primary';
                return _context22.abrupt("return", this._networkClient.fetchSDK({
                  url: endpoint,
                  body: requestBody,
                  errorMessage: 'Failed to send one time passcode',
                  method: 'POST'
                }));

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));
    }
  };
  this.email = {
    loginOrCreate: function loginOrCreate(email, options) {
      return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
        var captcha_token, requestBody;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.executeRecaptcha();

              case 2:
                captcha_token = _context23.sent;
                requestBody = Object.assign(Object.assign({}, options), {
                  email: email,
                  captcha_token: captcha_token
                });
                return _context23.abrupt("return", this._networkClient.fetchSDK({
                  url: '/otps/email/login_or_create',
                  body: requestBody,
                  errorMessage: 'Failed to send one time passcode',
                  method: 'POST'
                }));

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));
    },
    send: function send(email, options) {
      return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
        var captcha_token, requestBody, isLoggedIn, endpoint;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.executeRecaptcha();

              case 2:
                captcha_token = _context24.sent;
                requestBody = Object.assign(Object.assign({}, options), {
                  email: email,
                  captcha_token: captcha_token
                });
                isLoggedIn = !!this._subscriptionService.getSession();
                endpoint = isLoggedIn ? '/otps/email/send/secondary' : '/otps/email/send/primary';
                return _context24.abrupt("return", this._networkClient.fetchSDK({
                  url: endpoint,
                  body: requestBody,
                  errorMessage: 'Failed to send one time passcode',
                  method: 'POST'
                }));

              case 7:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));
    }
  };

  this.authenticate = function (code, method_id, options) {
    return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
      var requestBody, resp;
      return _regeneratorRuntime().wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              validate('stytch.otps.authenticate').isString('Code', code).isNumber('session_duration_minutes', options.session_duration_minutes);
              requestBody = Object.assign({
                token: code,
                method_id: method_id
              }, options);
              _context25.next = 4;
              return this._networkClient.fetchSDK({
                url: '/otps/authenticate',
                body: requestBody,
                errorMessage: 'Failed to authenticate token.',
                method: 'POST'
              });

            case 4:
              resp = _context25.sent;

              this._subscriptionService.updateState({
                session: resp.session,
                user: resp.user,
                session_token: resp.session_token,
                session_jwt: resp.session_jwt
              });

              return _context25.abrupt("return", omitUser(resp));

            case 7:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));
  };
});

var HeadlessOAuthClient = /*#__PURE__*/function () {
  function HeadlessOAuthClient(_networkClient, _subscriptionService, _pkceManager, _dynamicConfig, _config) {
    _classCallCheck(this, HeadlessOAuthClient);

    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._dynamicConfig = _dynamicConfig;
    this._config = _config;
    this.google = {
      start: this.startOAuthFlow(OAuthProviders.Google)
    };
    this.apple = {
      start: this.startOAuthFlow(OAuthProviders.Apple)
    };
    this.microsoft = {
      start: this.startOAuthFlow(OAuthProviders.Microsoft)
    };
    this.github = {
      start: this.startOAuthFlow(OAuthProviders.Github)
    };
    this.gitlab = {
      start: this.startOAuthFlow(OAuthProviders.GitLab)
    };
    this.facebook = {
      start: this.startOAuthFlow(OAuthProviders.Facebook)
    };
    this.discord = {
      start: this.startOAuthFlow(OAuthProviders.Discord)
    };
    this.slack = {
      start: this.startOAuthFlow(OAuthProviders.Slack)
    };
    this.amazon = {
      start: this.startOAuthFlow(OAuthProviders.Amazon)
    };
    this.bitbucket = {
      start: this.startOAuthFlow(OAuthProviders.Bitbucket)
    };
    this.linkedin = {
      start: this.startOAuthFlow(OAuthProviders.LinkedIn)
    };
    this.coinbase = {
      start: this.startOAuthFlow(OAuthProviders.Coinbase)
    };
    this.twitch = {
      start: this.startOAuthFlow(OAuthProviders.Twitch)
    };
  }

  _createClass(HeadlessOAuthClient, [{
    key: "authenticate",
    value: function authenticate(token, options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
        var keyPair, resp;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                validate('stytch.oauth.authenticate').isString('Token', token).isNumber('session_duration_minutes', options.session_duration_minutes);
                keyPair = this._pkceManager.getPKPair();

                if (!keyPair) {
                  logger.warn('No code verifier found in local storage for OAuth flow.\n' + 'Consider using stytch.oauth.$provider.start() to add PKCE to your OAuth flows for added security.\n' + 'See https://stytch.com/docs/oauth#guides_pkce for more information.');
                }

                _context26.next = 5;
                return this._networkClient.fetchSDK({
                  url: '/oauth/authenticate',
                  method: 'POST',
                  body: Object.assign({
                    token: token,
                    code_verifier: keyPair === null || keyPair === void 0 ? void 0 : keyPair.code_verifier
                  }, options),
                  errorMessage: 'Failed to authenticate token'
                });

              case 5:
                resp = _context26.sent;

                this._pkceManager.clearPKPair();

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: removeResponseCommon(resp.__user),
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context26.abrupt("return", omitUser(resp));

              case 9:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));
    }
  }, {
    key: "getBaseApiUrl",
    value: function getBaseApiUrl() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
        var _yield$this$_dynamicC, cnameDomain;

        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this._dynamicConfig;

              case 2:
                _yield$this$_dynamicC = _context27.sent;
                cnameDomain = _yield$this$_dynamicC.cnameDomain;

                if (!cnameDomain) {
                  _context27.next = 6;
                  break;
                }

                return _context27.abrupt("return", "https://".concat(cnameDomain));

              case 6:
                if (!isTestPublicToken(this._config.publicToken)) {
                  _context27.next = 8;
                  break;
                }

                return _context27.abrupt("return", this._config.testAPIURL);

              case 8:
                return _context27.abrupt("return", this._config.liveAPIURL);

              case 9:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));
    }
  }, {
    key: "startOAuthFlow",
    value: function startOAuthFlow(providerType) {
      var _this17 = this;

      return function () {
        var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            login_redirect_url = _ref7.login_redirect_url,
            signup_redirect_url = _ref7.signup_redirect_url,
            custom_scopes = _ref7.custom_scopes;

        return __awaiter(_this17, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
          var _yield$this$_dynamicC2, cnameDomain, pkceRequiredForOAuth, baseURL, oauthUrl, keyPair;

          return _regeneratorRuntime().wrap(function _callee28$(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  _context28.next = 2;
                  return this._dynamicConfig;

                case 2:
                  _yield$this$_dynamicC2 = _context28.sent;
                  cnameDomain = _yield$this$_dynamicC2.cnameDomain;
                  pkceRequiredForOAuth = _yield$this$_dynamicC2.pkceRequiredForOAuth;
                  _context28.next = 7;
                  return this.getBaseApiUrl();

                case 7:
                  baseURL = _context28.sent;

                  this._networkClient.logEvent({
                    name: 'start_oauth_flow',
                    details: {
                      provider_type: providerType,
                      custom_scopes: custom_scopes,
                      cname_domain: cnameDomain,
                      pkce: pkceRequiredForOAuth
                    }
                  });

                  oauthUrl = new URL("".concat(baseURL, "/v1/public/oauth/").concat(providerType, "/start"));
                  oauthUrl.searchParams.set('public_token', this._config.publicToken);

                  if (!pkceRequiredForOAuth) {
                    _context28.next = 18;
                    break;
                  }

                  _context28.next = 14;
                  return this._pkceManager.startPKCETransaction();

                case 14:
                  keyPair = _context28.sent;
                  oauthUrl.searchParams.set('code_challenge', keyPair.code_challenge);
                  _context28.next = 19;
                  break;

                case 18:
                  this._pkceManager.clearPKPair();

                case 19:
                  if (custom_scopes) {
                    validate('startOAuthFlow').isStringArray('custom_scopes', custom_scopes);
                    oauthUrl.searchParams.set('custom_scopes', custom_scopes.join(' '));
                  }

                  login_redirect_url && oauthUrl.searchParams.set('login_redirect_url', login_redirect_url);
                  signup_redirect_url && oauthUrl.searchParams.set('signup_redirect_url', signup_redirect_url);
                  window.location.href = oauthUrl.toString();

                case 23:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee28, this);
        }));
      };
    }
  }]);

  return HeadlessOAuthClient;
}();

var HeadlessCryptoWalletClient = /*#__PURE__*/function () {
  function HeadlessCryptoWalletClient(_networkClient, _subscriptionService) {
    var executeRecaptcha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
      return Promise.resolve(undefined);
    };

    _classCallCheck(this, HeadlessCryptoWalletClient);

    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this.executeRecaptcha = executeRecaptcha;
  }

  _createClass(HeadlessCryptoWalletClient, [{
    key: "authenticateStart",
    value: function authenticateStart(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
        var isLoggedIn, captcha_token, endpoint;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                validate('stytch.cryptoWallets.authenticateStart').isString('crypto_wallet_address', options.crypto_wallet_address).isString('crypto_wallet_type', options.crypto_wallet_type);
                isLoggedIn = !!this._subscriptionService.getSession();
                _context29.next = 4;
                return this.executeRecaptcha();

              case 4:
                captcha_token = _context29.sent;
                endpoint = isLoggedIn ? '/crypto_wallets/authenticate/start/secondary' : '/crypto_wallets/authenticate/start/primary';
                return _context29.abrupt("return", this._networkClient.fetchSDK({
                  url: endpoint,
                  method: 'POST',
                  errorMessage: 'Failed to start wallet authentication.',
                  body: {
                    crypto_wallet_address: options.crypto_wallet_address,
                    crypto_wallet_type: options.crypto_wallet_type,
                    captcha_token: captcha_token
                  }
                }));

              case 7:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                validate('stytch.cryptoWallets.authenticate').isString('signature', options.signature).isString('crypto_wallet_address', options.crypto_wallet_address).isString('crypto_wallet_type', options.crypto_wallet_type).isNumber('session_duration_minutes', options.session_duration_minutes);
                _context30.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/crypto_wallets/authenticate',
                  method: 'POST',
                  errorMessage: 'Failed to authenticate.',
                  body: {
                    session_duration_minutes: options.session_duration_minutes,
                    crypto_wallet_address: options.crypto_wallet_address,
                    crypto_wallet_type: options.crypto_wallet_type,
                    signature: options.signature
                  }
                });

              case 3:
                resp = _context30.sent;

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: removeResponseCommon(resp.__user),
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context30.abrupt("return", omitUser(resp));

              case 6:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));
    }
  }]);

  return HeadlessCryptoWalletClient;
}();

var HeadlessTOTPClient = /*#__PURE__*/function () {
  function HeadlessTOTPClient(_networkClient, _subscriptionService) {
    _classCallCheck(this, HeadlessTOTPClient);

    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
  }

  _createClass(HeadlessTOTPClient, [{
    key: "create",
    value: function create(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                validate('stytch.totps.create').isNumber('expiration_minutes', options.expiration_minutes);
                _context31.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/totps',
                  method: 'POST',
                  errorMessage: 'Failed to create TOTP',
                  body: {
                    expiration_minutes: options.expiration_minutes
                  }
                });

              case 3:
                resp = _context31.sent;

                this._subscriptionService.updateUser(resp.__user);

                return _context31.abrupt("return", omitUser(resp));

              case 6:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                validate('stytch.totps.authenticate').isNumber('session_duration_minutes', options.session_duration_minutes).isString('totp_code', options.totp_code);
                _context32.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/totps/authenticate',
                  method: 'POST',
                  errorMessage: 'Failed to authenticate TOTP',
                  body: {
                    session_duration_minutes: options.session_duration_minutes,
                    totp_code: options.totp_code
                  }
                });

              case 3:
                resp = _context32.sent;

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: resp.__user,
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context32.abrupt("return", omitUser(resp));

              case 6:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));
    }
  }, {
    key: "recoveryCodes",
    value: function recoveryCodes() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                return _context33.abrupt("return", this._networkClient.fetchSDK({
                  url: '/totps/recovery_codes',
                  method: 'POST',
                  errorMessage: 'Failed to retrieve recovery codes'
                }));

              case 1:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));
    }
  }, {
    key: "recover",
    value: function recover(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                validate('stytch.totps.recover').isNumber('session_duration_minutes', options.session_duration_minutes).isString('recovery_code', options.recovery_code);
                _context34.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/totps/recover',
                  method: 'POST',
                  errorMessage: 'Failed to recover TOTP',
                  body: {
                    session_duration_minutes: options.session_duration_minutes,
                    recovery_code: options.recovery_code
                  }
                });

              case 3:
                resp = _context34.sent;

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: resp.__user,
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context34.abrupt("return", omitUser(resp));

              case 6:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));
    }
  }]);

  return HeadlessTOTPClient;
}(); // src/webauthn-json/base64url.ts


function base64urlToBuffer(baseurl64String) {
  var padding = "==".slice(0, (4 - baseurl64String.length % 4) % 4);
  var base64String = baseurl64String.replace(/-/g, "+").replace(/_/g, "/") + padding;
  var str = atob(base64String);
  var buffer = new ArrayBuffer(str.length);
  var byteView = new Uint8Array(buffer);

  for (var _i2 = 0; _i2 < str.length; _i2++) {
    byteView[_i2] = str.charCodeAt(_i2);
  }

  return buffer;
}

function bufferToBase64url(buffer) {
  var byteView = new Uint8Array(buffer);
  var str = "";

  var _iterator2 = _createForOfIteratorHelper(byteView),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var charCode = _step2.value;
      str += String.fromCharCode(charCode);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var base64String = btoa(str);
  var base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return base64urlString;
} // src/webauthn-json/convert.ts


var copyValue = "copy";
var convertValue = "convert";

function convert(conversionFn, schema2, input) {
  if (schema2 === copyValue) {
    return input;
  }

  if (schema2 === convertValue) {
    return conversionFn(input);
  }

  if (schema2 instanceof Array) {
    return input.map(function (v) {
      return convert(conversionFn, schema2[0], v);
    });
  }

  if (schema2 instanceof Object) {
    var output = {};

    for (var _i3 = 0, _Object$entries = Object.entries(schema2); _i3 < _Object$entries.length; _i3++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
          key = _Object$entries$_i[0],
          schemaField = _Object$entries$_i[1];

      if (schemaField.derive) {
        var v = schemaField.derive(input);

        if (v !== void 0) {
          input[key] = v;
        }
      }

      if (!(key in input)) {
        if (schemaField.required) {
          throw new Error("Missing key: ".concat(key));
        }

        continue;
      }

      if (input[key] == null) {
        output[key] = null;
        continue;
      }

      output[key] = convert(conversionFn, schemaField.schema, input[key]);
    }

    return output;
  }
}

function derived(schema2, derive) {
  return {
    required: true,
    schema: schema2,
    derive: derive
  };
}

function required(schema2) {
  return {
    required: true,
    schema: schema2
  };
}

function optional(schema2) {
  return {
    required: false,
    schema: schema2
  };
} // src/webauthn-json/basic/schema.ts


var publicKeyCredentialDescriptorSchema = {
  type: required(copyValue),
  id: required(convertValue),
  transports: optional(copyValue)
};
var simplifiedExtensionsSchema = {
  appid: optional(copyValue),
  appidExclude: optional(copyValue),
  credProps: optional(copyValue)
};
var simplifiedClientExtensionResultsSchema = {
  appid: optional(copyValue),
  appidExclude: optional(copyValue),
  credProps: optional(copyValue)
};
var credentialCreationOptions = {
  publicKey: required({
    rp: required(copyValue),
    user: required({
      id: required(convertValue),
      name: required(copyValue),
      displayName: required(copyValue)
    }),
    challenge: required(convertValue),
    pubKeyCredParams: required(copyValue),
    timeout: optional(copyValue),
    excludeCredentials: optional([publicKeyCredentialDescriptorSchema]),
    authenticatorSelection: optional(copyValue),
    attestation: optional(copyValue),
    extensions: optional(simplifiedExtensionsSchema)
  }),
  signal: optional(copyValue)
};
var publicKeyCredentialWithAttestation = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    attestationObject: required(convertValue),
    transports: derived(copyValue, function (response) {
      var _a;

      return ((_a = response.getTransports) == null ? void 0 : _a.call(response)) || [];
    })
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, function (pkc) {
    return pkc.getClientExtensionResults();
  })
};
var credentialRequestOptions = {
  mediation: optional(copyValue),
  publicKey: required({
    challenge: required(convertValue),
    timeout: optional(copyValue),
    rpId: optional(copyValue),
    allowCredentials: optional([publicKeyCredentialDescriptorSchema]),
    userVerification: optional(copyValue),
    extensions: optional(simplifiedExtensionsSchema)
  }),
  signal: optional(copyValue)
};
var publicKeyCredentialWithAssertion = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    authenticatorData: required(convertValue),
    signature: required(convertValue),
    userHandle: required(convertValue)
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, function (pkc) {
    return pkc.getClientExtensionResults();
  })
}; // src/webauthn-json/basic/api.ts

function createRequestFromJSON(requestJSON) {
  return convert(base64urlToBuffer, credentialCreationOptions, requestJSON);
}

function createResponseToJSON(credential) {
  return convert(bufferToBase64url, publicKeyCredentialWithAttestation, credential);
}

function create(requestJSON) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {
    var credential;
    return _regeneratorRuntime().wrap(function _callee35$(_context35) {
      while (1) {
        switch (_context35.prev = _context35.next) {
          case 0:
            _context35.next = 2;
            return navigator.credentials.create(createRequestFromJSON(requestJSON));

          case 2:
            credential = _context35.sent;
            return _context35.abrupt("return", createResponseToJSON(credential));

          case 4:
          case "end":
            return _context35.stop();
        }
      }
    }, _callee35);
  }));
}

function getRequestFromJSON(requestJSON) {
  return convert(base64urlToBuffer, credentialRequestOptions, requestJSON);
}

function getResponseToJSON(credential) {
  return convert(bufferToBase64url, publicKeyCredentialWithAssertion, credential);
}

function get(requestJSON) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {
    var credential;
    return _regeneratorRuntime().wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            _context36.next = 2;
            return navigator.credentials.get(getRequestFromJSON(requestJSON));

          case 2:
            credential = _context36.sent;
            return _context36.abrupt("return", getResponseToJSON(credential));

          case 4:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));
}

var HeadlessWebAuthnClient = /*#__PURE__*/function () {
  function HeadlessWebAuthnClient(_networkClient, _subscriptionService) {
    _classCallCheck(this, HeadlessWebAuthnClient);

    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
  }

  _createClass(HeadlessWebAuthnClient, [{
    key: "register",
    value: function register(options) {
      var _a;

      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
        var startResp, publicKeyCredentialCreationOptions, credential, resp;
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                validate('stytch.webauthn.register').isOptionalString('domain', options === null || options === void 0 ? void 0 : options.domain).isOptionalString('authenticator_type', options === null || options === void 0 ? void 0 : options.authenticator_type);
                _context37.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/webauthn/register/start',
                  method: 'POST',
                  errorMessage: 'Failed to start WebAuthn registration',
                  body: {
                    domain: (_a = options === null || options === void 0 ? void 0 : options.domain) !== null && _a !== void 0 ? _a : window.location.hostname,
                    authenticator_type: options === null || options === void 0 ? void 0 : options.authenticator_type
                  }
                });

              case 3:
                startResp = _context37.sent;
                publicKeyCredentialCreationOptions = startResp.public_key_credential_creation_options;
                _context37.next = 7;
                return create({
                  publicKey: JSON.parse(publicKeyCredentialCreationOptions)
                });

              case 7:
                credential = _context37.sent;
                _context37.next = 10;
                return this._networkClient.fetchSDK({
                  url: '/webauthn/register',
                  method: 'POST',
                  errorMessage: 'Failed to register WebAuthn device',
                  body: {
                    public_key_credential: JSON.stringify(credential)
                  }
                });

              case 10:
                resp = _context37.sent;

                this._subscriptionService.updateUser(resp.__user);

                return _context37.abrupt("return", omitUser(resp));

              case 13:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      var _a;

      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {
        var startResp, publicKeyCredentialRequestOptions, credential, authenticationData;
        return _regeneratorRuntime().wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                validate('stytch.webauthn.register').isOptionalString('domain', options.domain).isNumber('session_duration_minutes', options.session_duration_minutes);
                _context38.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/webauthn/authenticate/start',
                  method: 'POST',
                  errorMessage: 'Failed to start WebAuthn authentication',
                  body: {
                    domain: (_a = options.domain) !== null && _a !== void 0 ? _a : window.location.hostname
                  }
                });

              case 3:
                startResp = _context38.sent;
                publicKeyCredentialRequestOptions = startResp.public_key_credential_request_options;
                _context38.next = 7;
                return get({
                  publicKey: JSON.parse(publicKeyCredentialRequestOptions)
                });

              case 7:
                credential = _context38.sent;
                _context38.next = 10;
                return this._networkClient.fetchSDK({
                  url: '/webauthn/authenticate',
                  method: 'POST',
                  errorMessage: 'Failed to authenticate WebAuthn device',
                  body: {
                    public_key_credential: JSON.stringify(credential),
                    session_duration_minutes: options.session_duration_minutes
                  }
                });

              case 10:
                authenticationData = _context38.sent;

                this._subscriptionService.updateState({
                  session: authenticationData.session,
                  user: authenticationData.__user,
                  session_token: authenticationData.session_token,
                  session_jwt: authenticationData.session_jwt
                });

                return _context38.abrupt("return", omitUser(authenticationData));

              case 13:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));
    }
  }]);

  return HeadlessWebAuthnClient;
}();

var DefaultDynamicConfig = Promise.resolve({
  pkceRequiredForPasswordResets: false
});

var HeadlessPasswordClient = /*#__PURE__*/function () {
  function HeadlessPasswordClient(_networkClient, _subscriptionService, _pkceManager) {
    var _config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultDynamicConfig;

    var executeRecaptcha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
      return Promise.resolve(undefined);
    };

    _classCallCheck(this, HeadlessPasswordClient);

    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._config = _config;
    this.executeRecaptcha = executeRecaptcha;
  }

  _createClass(HeadlessPasswordClient, [{
    key: "getCodeChallenge",
    value: function getCodeChallenge() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {
        var _yield$this$_config3, pkceRequiredForPasswordResets, keyPair;

        return _regeneratorRuntime().wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                _context39.next = 2;
                return this._config;

              case 2:
                _yield$this$_config3 = _context39.sent;
                pkceRequiredForPasswordResets = _yield$this$_config3.pkceRequiredForPasswordResets;

                if (pkceRequiredForPasswordResets) {
                  _context39.next = 6;
                  break;
                }

                return _context39.abrupt("return", undefined);

              case 6:
                keyPair = this._pkceManager.getPKPair();

                if (!keyPair) {
                  _context39.next = 9;
                  break;
                }

                return _context39.abrupt("return", keyPair.code_challenge);

              case 9:
                _context39.next = 11;
                return this._pkceManager.startPKCETransaction();

              case 11:
                keyPair = _context39.sent;
                return _context39.abrupt("return", keyPair.code_challenge);

              case 13:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));
    }
  }, {
    key: "create",
    value: function create(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        var captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                validate('stytch.passwords.create').isString('password', options.password).isString('email', options.email).isNumber('session_duration_minutes', options.session_duration_minutes);
                _context40.next = 3;
                return this.executeRecaptcha();

              case 3:
                captcha_token = _context40.sent;
                _context40.next = 6;
                return this._networkClient.fetchSDK({
                  url: '/passwords',
                  method: 'POST',
                  errorMessage: 'Failed to create password.',
                  body: {
                    email: options.email,
                    password: options.password,
                    session_duration_minutes: options.session_duration_minutes,
                    captcha_token: captcha_token
                  }
                });

              case 6:
                resp = _context40.sent;

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: resp.user,
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context40.abrupt("return", omitUser(resp));

              case 9:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
        var captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                validate('stytch.passwords.authenticate').isString('password', options.password).isString('email', options.email).isNumber('session_duration_minutes', options.session_duration_minutes);
                _context41.next = 3;
                return this.executeRecaptcha();

              case 3:
                captcha_token = _context41.sent;
                _context41.next = 6;
                return this._networkClient.fetchSDK({
                  url: '/passwords/authenticate',
                  method: 'POST',
                  errorMessage: 'Failed to authenticate password.',
                  body: {
                    email: options.email,
                    password: options.password,
                    session_duration_minutes: options.session_duration_minutes,
                    captcha_token: captcha_token
                  }
                });

              case 6:
                resp = _context41.sent;

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: resp.user,
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context41.abrupt("return", omitUser(resp));

              case 9:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));
    }
  }, {
    key: "resetByEmailStart",
    value: function resetByEmailStart(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
        var code_challenge, captcha_token;
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                validate('stytch.passwords.resetByEmailStart').isString('email', options.email).isOptionalString('login_redirect_url', options.login_redirect_url).isOptionalString('reset_password_redirect_url', options.reset_password_redirect_url).isOptionalNumber('reset_password_expiration_minutes', options.reset_password_expiration_minutes);
                _context42.next = 3;
                return this.getCodeChallenge();

              case 3:
                code_challenge = _context42.sent;
                _context42.next = 6;
                return this.executeRecaptcha();

              case 6:
                captcha_token = _context42.sent;
                return _context42.abrupt("return", this._networkClient.fetchSDK({
                  url: '/passwords/email/reset/start',
                  method: 'POST',
                  errorMessage: 'Failed to start password reset flow.',
                  body: {
                    email: options.email,
                    login_redirect_url: options.login_redirect_url,
                    reset_password_redirect_url: options.reset_password_redirect_url,
                    reset_password_expiration_minutes: options.reset_password_expiration_minutes,
                    code_challenge: code_challenge,
                    captcha_token: captcha_token
                  }
                }));

              case 8:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));
    }
  }, {
    key: "resetByEmail",
    value: function resetByEmail(options) {
      var _a;

      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {
        var captcha_token, code_verifier, resp;
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                validate('stytch.passwords.resetByEmail').isString('token', options.token).isString('password', options.password).isNumber('session_duration_minutes', options.session_duration_minutes);
                _context43.next = 3;
                return this.executeRecaptcha();

              case 3:
                captcha_token = _context43.sent;
                code_verifier = (_a = this._pkceManager.getPKPair()) === null || _a === void 0 ? void 0 : _a.code_verifier;
                _context43.next = 7;
                return this._networkClient.fetchSDK({
                  url: '/passwords/email/reset',
                  method: 'POST',
                  errorMessage: 'Failed to reset password.',
                  body: {
                    token: options.token,
                    password: options.password,
                    session_duration_minutes: options.session_duration_minutes,
                    captcha_token: captcha_token,
                    code_verifier: code_verifier
                  }
                });

              case 7:
                resp = _context43.sent;

                this._pkceManager.clearPKPair();

                this._subscriptionService.updateState({
                  session: resp.session,
                  user: resp.user,
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt
                });

                return _context43.abrupt("return", omitUser(resp));

              case 11:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));
    }
  }, {
    key: "resetByExistingPassword",
    value: function resetByExistingPassword(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                validate('stytch.passwords.resetByExistingPassword').isString('email', options.email).isString('existing_password', options.existing_password).isString('new_password', options.new_password);
                _context44.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/passwords/existing_password/reset',
                  method: 'POST',
                  errorMessage: 'Failed to reset password.',
                  body: {
                    email: options.email,
                    existing_password: options.existing_password,
                    new_password: options.new_password
                  }
                });

              case 3:
                resp = _context44.sent;
                return _context44.abrupt("return", omitUser(resp));

              case 5:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));
    }
  }, {
    key: "resetBySession",
    value: function resetBySession(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee45() {
        return _regeneratorRuntime().wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                validate('stytch.passwords.resetBySession').isString('password', options.password);
                _context45.next = 3;
                return this._networkClient.fetchSDK({
                  url: '/passwords/session/reset',
                  method: 'POST',
                  errorMessage: 'Failed to reset session.',
                  body: {
                    password: options.password
                  }
                });

              case 3:
                return _context45.abrupt("return", _context45.sent);

              case 4:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this);
      }));
    }
  }, {
    key: "strengthCheck",
    value: function strengthCheck(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee46() {
        return _regeneratorRuntime().wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                validate('stytch.passwords.strengthCheck').isOptionalString('email', options.email).isString('password', options.password);
                return _context46.abrupt("return", this._networkClient.fetchSDK({
                  url: '/passwords/strength_check',
                  method: 'POST',
                  errorMessage: 'Failed to check password strength.',
                  body: {
                    email: options.email,
                    password: options.password
                  }
                }));

              case 2:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this);
      }));
    }
  }]);

  return HeadlessPasswordClient;
}();

exports.CLIENTSIDE_SERVICES_IFRAME_URL = CLIENTSIDE_SERVICES_IFRAME_URL;
exports.DEFAULT_INTERVAL_DURATION_MS = DEFAULT_INTERVAL_DURATION_MS;
exports.DEFAULT_MAX_BATCH_SIZE = DEFAULT_MAX_BATCH_SIZE;
exports.DEFAULT_OTP_EXPIRATION_MINUTES = DEFAULT_OTP_EXPIRATION_MINUTES;
exports.DEFAULT_SESSION_DURATION_MINUTES = DEFAULT_SESSION_DURATION_MINUTES;
exports.ErrorMarshaller = ErrorMarshaller;
exports.EventLogger = EventLogger;
exports.GOOGLE_ONE_TAP_HOST = GOOGLE_ONE_TAP_HOST;
exports.GOOGLE_ONE_TAP_SCRIPT_URL = GOOGLE_ONE_TAP_SCRIPT_URL;
exports.HeadlessCryptoWalletClient = HeadlessCryptoWalletClient;
exports.HeadlessMagicLinksClient = HeadlessMagicLinksClient;
exports.HeadlessOAuthClient = HeadlessOAuthClient;
exports.HeadlessOTPClient = HeadlessOTPClient;
exports.HeadlessPasswordClient = HeadlessPasswordClient;
exports.HeadlessSessionClient = HeadlessSessionClient;
exports.HeadlessTOTPClient = HeadlessTOTPClient;
exports.HeadlessUserClient = HeadlessUserClient;
exports.HeadlessWebAuthnClient = HeadlessWebAuthnClient;
exports.IframeEmbeddedClient = IframeEmbeddedClient;
exports.IframeHostClient = IframeHostClient;
exports.LIVE_API_URL = LIVE_API_URL;
exports.POWERED_BY_STYTCH_IMG_URL = POWERED_BY_STYTCH_IMG_URL;
exports.STYTCH_CSRF_TOKEN_NAME = STYTCH_CSRF_TOKEN_NAME;
exports.STYTCH_SESSION_COOKIE = STYTCH_SESSION_COOKIE;
exports.STYTCH_SESSION_JWT_COOKIE = STYTCH_SESSION_JWT_COOKIE;
exports.STYTCH_WEB_BACKEND_URL = STYTCH_WEB_BACKEND_URL;
exports.SessionManager = SessionManager;
exports.SubscriptionDataLayer = SubscriptionDataLayer;
exports.SubscriptionService = SubscriptionService;
exports.TEST_API_URL = TEST_API_URL;
exports.baseFetchSDK = baseFetchSDK;
exports.checkNotSSR = checkNotSSR;
exports.checkPublicToken = checkPublicToken;
exports.createAppSessionId = createAppSessionId;
exports.createDeepEqual = createDeepEqual;
exports.createEventId = createEventId;
exports.createPersistentId = createPersistentId;
exports.isEmailMethod = isEmailMethod;
exports.isPhoneMethod = isPhoneMethod;
exports.isTestPublicToken = isTestPublicToken;
exports.loadESModule = loadESModule;
exports.logger = logger;
exports.normalizePromiseLike = normalizePromiseLike;
exports.omitUser = omitUser;
exports.removeResponseCommon = removeResponseCommon;
exports.validate = validate;
