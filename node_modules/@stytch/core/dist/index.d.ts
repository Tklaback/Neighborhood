declare const TEST_API_URL = "https://test.stytch.com";
declare const LIVE_API_URL = "https://api.stytch.com";
declare const CLIENTSIDE_SERVICES_IFRAME_URL = "https://js.stytch.com/clientside-services/index.html";
declare const STYTCH_WEB_BACKEND_URL = "https://web.stytch.com";
declare const STYTCH_SESSION_COOKIE = "stytch_session";
declare const STYTCH_SESSION_JWT_COOKIE = "stytch_session_jwt";
declare const POWERED_BY_STYTCH_IMG_URL = "https://public-assets.stytch.com/et_powered_by_stytch_logo.png";
declare const GOOGLE_ONE_TAP_HOST = "https://accounts.google.com/gsi";
declare const GOOGLE_ONE_TAP_SCRIPT_URL: string;
declare const STYTCH_CSRF_TOKEN_NAME = "stytch_csrf_private_token";
declare const DEFAULT_SESSION_DURATION_MINUTES = 30;
declare const DEFAULT_OTP_EXPIRATION_MINUTES = 5;
/**
 * Some errors are thrown from inside an iframe, but we can't serialize them
 * to the parent in Webkit. This class handles casting them to plain objects,
 * and restoring them on the other side. (ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®ðŸ¤®)
 * It preserves the error instance/class constructor by inspecting err.name
 * and calling `new` on the matching constructor.
 */
declare class ErrorMarshaller {
    static marshall(error: Error): Record<string, unknown>;
    static inflate<T extends {
        new (...any: never[]): Error;
    }>(ErrorClass: T, ErrorData: Record<string, unknown>): Error;
    static unmarshall(error: Record<string, unknown>): Error;
}
declare class IframeHostClient {
    private iframeURL;
    frame: Promise<HTMLIFrameElement>;
    constructor(iframeURL: string);
    private createIframe;
    call<T>(method: string, args: unknown[]): Promise<T>;
}
declare class IframeEmbeddedClient {
    handlers: Record<string, (...args: unknown[]) => Promise<unknown>>;
    constructor();
    runHandler(event: MessageEvent): Promise<void>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerHandler(handler: string, handlerImpl: (...args: any[]) => Promise<unknown>): void;
}
/**
 * All RPC Methods we currently support.
 * Remember - once you add an RPC method, it must be backwards compatible --- FOREVER!
 * Making breaking changes can break old versions of vanilla-js, so proceed with caution.
 *
 * I'll repeat it again - YOU CANNOT MAKE BACKWARDS INCOMPATIBLE CHANGES TO THIS FILE.
 *
 * Rules of thumb:
 * - RPC methods should take in Object { } options and return Objects {} - this makes it far easier to add more params later
 * - Prefer one big single param over n-ary arguments.
 * - Make everything async. You'll never know if you'll add an async function call in the future.
 * - If you need to break a method, call it method2 and move on.
 */
interface RPCManifest {
    oneTapStart: (req: OneTapStartRequest) => Promise<OneTapStartResponse>;
    oneTapSubmit: (req: OneTapSubmitRequest) => Promise<OneTapSubmitResponse>;
}
type OneTapStartRequest = {
    publicToken: string;
};
type OneTapStartResponse = {
    requestId: string;
    googleClientId: string;
    stytchCsrfToken: string;
    oauthCallbackId: string;
};
type OneTapSubmitRequest = {
    publicToken: string;
    idToken: string;
    oauthCallbackID: string;
    loginRedirectURL?: string;
    signupRedirectURL?: string;
};
type OneTapSubmitResponse = {
    redirect_url: string;
};
// Factors
interface EmailFactor {
    delivery_method: "email" | "embedded";
    type: string;
    last_authenticated_at: string;
    email_factor: {
        email_id: string;
        email_address: string;
    };
}
interface PhoneNumberFactor {
    delivery_method: "sms" | "whatsapp";
    type: string;
    last_authenticated_at: string;
    phone_number_factor: {
        phone_id: string;
        phone_number: string;
    };
}
interface GoogleOAuthFactor {
    delivery_method: "oauth_google";
    type: string;
    last_authenticated_at: string;
    google_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface MicrosoftOAuthFactor {
    delivery_method: "oauth_microsoft";
    type: string;
    last_authenticated_at: string;
    microsoft_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface AppleOAuthFactor {
    delivery_method: "oauth_apple";
    type: string;
    last_authenticated_at: string;
    apple_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface GithubOAuthFactor {
    delivery_method: "oauth_github";
    type: string;
    last_authenticated_at: string;
    github_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface GitLabOAuthFactor {
    delivery_method: "oauth_gitlab";
    type: string;
    last_authenticated_at: string;
    gitlab_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface FacebookOAuthFactor {
    delivery_method: "oauth_facebook";
    type: string;
    last_authenticated_at: string;
    facebook_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface DiscordOAuthFactor {
    delivery_method: "oauth_discord";
    type: string;
    last_authenticated_at: string;
    discord_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface SlackOAuthFactor {
    delivery_method: "oauth_slack";
    type: string;
    last_authenticated_at: string;
    slack_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface AmazonOAuthFactor {
    delivery_method: "oauth_amazon";
    type: string;
    last_authenticated_at: string;
    amazon_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface BitbucketOAuthFactor {
    delivery_method: "oauth_bitbucket";
    type: string;
    last_authenticated_at: string;
    bitbucket_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface LinkedInOAuthFactor {
    delivery_method: "oauth_linkedin";
    type: string;
    last_authenticated_at: string;
    linkedin_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface CoinbaseOAuthFactor {
    delivery_method: "oauth_coinbase";
    type: string;
    last_authenticated_at: string;
    coinbase_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface TwitchOAuthFactor {
    delivery_method: "oauth_twitch";
    type: string;
    last_authenticated_at: string;
    twitch_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface WebAuthnFactor {
    delivery_method: "webauthn_registration";
    type: string;
    last_authenticated_at: string;
    webauthn_factor: {
        webauthn_registration_id: string;
        domain: string;
        user_agent: string;
    };
}
interface AuthenticatorAppFactor {
    delivery_method: "authenticator_app";
    type: string;
    last_authenticated_at: string;
    authenticator_app_factor: {
        totp_id: string;
    };
}
interface RecoveryCodeFactor {
    delivery_method: "recovery_code";
    type: string;
    last_authenticated_at: string;
    recovery_code_factor: {
        totp_recovery_code_id: string;
    };
}
interface CryptoWalletFactor {
    delivery_method: "crypto_wallet";
    type: string;
    last_authenticated_at: string;
    crypto_wallet_factor: {
        crypto_wallet_id: string;
        crypto_wallet_address: string;
        crypto_wallet_type: string;
    };
}
interface PasswordFactor {
    delivery_method: "knowledge";
    type: string;
    last_authenticated_at: string;
}
type AuthenticationFactor = EmailFactor | PhoneNumberFactor | GoogleOAuthFactor | MicrosoftOAuthFactor | AppleOAuthFactor | GithubOAuthFactor | GitLabOAuthFactor | FacebookOAuthFactor | DiscordOAuthFactor | SlackOAuthFactor | AmazonOAuthFactor | BitbucketOAuthFactor | LinkedInOAuthFactor | CoinbaseOAuthFactor | TwitchOAuthFactor | WebAuthnFactor | AuthenticatorAppFactor | RecoveryCodeFactor | CryptoWalletFactor | PasswordFactor;
type Session = {
    attributes: {
        ip_address: string;
        user_agent: string;
    };
    /**
     * All the authentication factors that have been associated with the current session.
     * @example
     * const userIsMFAd = session.authentication_factors.length > 2;
     */
    authentication_factors: Array<AuthenticationFactor>;
    /**
     * The timestamp of the session's expiration.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    expires_at: string;
    /**
     * The timestamp of the last time the session was accessed.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    last_accessed_at: string;
    /**
     * Globally unique UUID that identifies a specific session in the Stytch API.
     */
    session_id: string;
    /**
     * The timestamp of the session's creation.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    started_at: string;
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * A map of the custom claims associated with the session.
     * Custom claims can only be set from the server, they cannot be set using the clientside SDKs.
     * After claims have been added to a session, call {@link IHeadlessSessionClient#authenticate stytch.sessions.authenticate} to refresh the session state clientside.
     * See our {@link https://stytch.com/docs/sessions#using-sessions_custom-claims guide} for more information.
     * If no claims are set, this field will be null.
     */
    custom_claims: null | Record<string, unknown>;
};
type SessionAuthenticateOptions = Partial<SessionDurationOptions>;
type SessionAuthenticateResponse = AuthenticateResponse;
type SessionRevokeResponse = ResponseCommon;
type SessionOnChangeCallback = (session: Session | null) => void;
type SessionTokens = {
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/api/session-auth SessionsAuthenticate}
     * endpoint before a user takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * You can retrieve your project's public keyset via our {@link https://stytch.com/docs/api/jwks-get GetJWKS} endpoint
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string;
};
interface IHeadlessSessionClient {
    /**
     * If logged in, `getSync` returns the in-memory session object. Otherwise, it returns `null`.
     * @example
     * const sess = stytch.session.getSync();
     * const hasWebAuthn = sess.authentication_factors.find(
     *   factor => factor.delivery_method === 'webauthn_registration'
     * );
     * @returns The user's active {@link Session} object or `null`
     */
    getSync(): Session | null;
    /**
     * If logged in, `getTokens` returns the session tokens currently issued to the client.
     * Stytch issues two types of tokens - opaque bearer tokens and JWTs.
     * See Stytch's {@link https://stytch.com/docs/sessions#using-sessions session management guide} for an explanation of the difference between the two.
     * On each request authenticate the user's session on the backend using one of Stytch's client libraries.
     *
     * @example
     * const {session_jwt} = stytch.session.getTokens();
     * fetch('https://api.example.com, {
     *   headers: new Headers({
     *    'Authorization': 'Bearer ' + session_jwt,
     *    credentials: 'include',
     *   }),
     * })
     *
     */
    getTokens(): SessionTokens | null;
    /**
     * Use `onChange` to register a listener for session change events.
     * If using `@stytch/react` or `@stytch/nextjs` - you may prefer the `useStytchSession` hook.
     * @example
     * stytch.session.onChange((sess) => {
     *   if(!sess) {
     *     // The user has been logged out!
     *     window.location.href = 'https://example.com/login'
     *   }
     * })
     * @param callback - {@link SessionOnChangeCallback}
     */
    onChange(callback: SessionOnChangeCallback): UnsubscribeFunction;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/session-auth authenticate } Session endpoint and validates that the session issued to the user is still valid.
     * You can call this method to programmatically extend the lifetime of the user's existing session
     * If you're trying to determine if the user is logged in, call {@link IHeadlessSessionClient.getSync} instead.
     * @example
     * stytch.session.authenticate({
     *   // Extend the session for another 60 minutes
     *   session_duration_minutes: 60
     * })
     * @param options - {@link SessionAuthenticateOptions}
     * @returns A {@link SessionAuthenticateResponse}
     */
    authenticate(options?: SessionAuthenticateOptions): Promise<SessionAuthenticateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/session-revoke revoke} Session endpoint and revokes the user's current session.
     * This method should be used to log out a user.
     * @example
     * stytch.sessions.revoke()
     *   .then(() => window.location.href = 'https://example.com/login');
     * @returns A {@link SessionRevokeResponse}
     */
    revoke(): Promise<SessionRevokeResponse>;
}
type ResponseCommon = {
    /**
     * Globally unique UUID that is returned with every API call.
     * This value is important to log for debugging purposes;
     * Stytch may ask for this value to help identify a specific API call when helping you debug an issue.
     */
    request_id: string;
    /**
     * The HTTP status code of the response.
     * Stytch follows standard HTTP response status code patterns, e.g. 2XX values equate to success,
     * 3XX values are redirects, 4XX are client errors, and 5XX are server errors.
     */
    status_code: number;
};
type User = {
    /**
     * The timestamp of the user's creation.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    created_at: string;
    /**
     * The `crypto_wallets` array contains a list of all crypto wallets that a user has linked via Stytch.
     */
    crypto_wallets: Array<{
        /**
         * Globally unique UUID that identifies a specific crypto wallet in the Stytch API.
         * The `crypto_wallet_id` is used when you need to operate on a specific user's crypto wallet, e.g. to remove the crypto wallet from the Stytch user.
         */
        crypto_wallet_id: string;
        /**
         * The `crypto_wallet_address` is the actual blockchain address of this user's crypto wallet.
         */
        crypto_wallet_address: string;
        /**
         * The `crypto_wallet_type` is the blockchain that the user's crypto wallet operates on, e.g. Ethereum, Solana, etc.
         */
        crypto_wallet_type: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    /**
     * The `emails` array contains an array of `email` objects for the user.
     */
    emails: Array<{
        /**
         * The email address.
         */
        email: string;
        /**
         * Globally unique UUID that identifies a specific email address in the Stytch API.
         * The `email_id` is used when you need to operate on a specific user's email address,
         * e.g. to delete the email address from the Stytch user.
         */
        email_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    name: {
        first_name: string;
        last_name: string;
        middle_name: string;
    };
    /**
     * The `phone_numbers` array contains an array of phone number objects for the user.
     */
    phone_numbers: Array<{
        /**
         * A phone number.
         */
        phone_number: string;
        /**
         * Globally unique UUID that identifies a specific phone number in the Stytch API.
         * The `phone_id` is used when you need to operate on a specific user's phone number,
         * e.g. to delete the phone number from the Stytch user.
         */
        phone_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    /**
     * The `providers` array contains an array of provider objects for the user, i.e. which OAuth providers the user has used to link their account.
     */
    providers: Array<{
        /**
         * The `provider_subject` field is the unique identifier used to identify the user within a given OAuth provider.
         * Also commonly called the "sub" or "Subject field" in OAuth protocols.
         */
        provider_subject: string;
        /**
         * The `type` field denotes the OAuth identity provider that the user has authenticated with, e.g. Google, Facebook, GitHub etc.
         */
        provider_type: string;
        /**
         * If available, the `profile_picture_url` is a url of the user's profile picture set in OAuth identity the provider that the user has authenticated with, e.g. Facebook profile picture.
         */
        profile_picture_url: string;
        /**
         * If available, the `locale` is the user's locale set in the OAuth identity provider that the user has authenticated with.
         */
        locale: string;
    }>;
    /**
     * The `password` object is returned for users with a password.
     */
    password: null | {
        /**
         * Globally unique UUID that identifies a specific password in the Stytch API.
         */
        password_id: string;
        /**
         * The `requires_reset` field indicates whether the user will need to reset their password to use it in the future.
         * See {@link https://stytch.com/docs/api/password-authenticate the API docs} for explanations of scenarios where
         * this might be required.
         */
        requires_reset: boolean;
    };
    /**
     * The `status` value denotes whether or not a user has successfully logged in at least once with any available login method.
     * Possible values are `active` and `pending`.
     */
    status: "active" | "pending";
    /**
     * The `totps` array contains a list of all TOTP instances for a given user in the Stytch API.
     */
    totps: Array<{
        /**
         * Globally unique UUID that identifies a specific TOTP instance in the Stytch API.
         * The `totp_id` is used when you need to operate on a specific user's TOTP instance, e.g. to delete the TOTP instance from the Stytch user.
         */
        totp_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
    /**
     * The `webauthn_registrations` array contains a list of all WebAuthn registrations for a given user in the Stytch API.
     */
    webauthn_registrations: Array<{
        /**
         * The `domain` on which a WebAuthn registration was started.
         * This will be the domain of your app.
         */
        domain: string;
        /**
         * The `user_agent` of the user's browser or device.
         */
        user_agent: string;
        /**
         * The `authenticator_type` string displays the requested authenticator type of the WebAuthn device.
         * The two valid types are "platform" and "cross-platform".
         * If no value is present, the WebAuthn device was created without an authenticator type preference.
         */
        authenticator_type: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
        /**
         * Globally unique UUID that identifies a specific WebAuthn registration in the Stytch API.
         * The `webauthn_registration_id` is used when you need to operate on a specific user's WebAuthn registration,
         * e.g. to delete the WebAuthn instance from the Stytch user.
         */
        webauthn_registration_id: string;
    }>;
};
type AuthenticateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/api/session-auth SessionsAuthenticate}
     * endpoint before a user takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * You can retrieve your project's public keyset via our {@link https://stytch.com/docs/api/jwks-get GetJWKS} endpoint
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string;
    /**
     * The Session object created.
     * See {@link Session} for details.
     */
    session: Session;
    /**
     * The user object affected by this API call.
     * See the {@link https://stytch.com/docs/api/get-user Get user} endpiont for complete response field detail.
     */
    user: User;
};
type DeleteResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
};
type UpdateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
};
type SessionDurationOptions = {
    /**
     * Set the session lifetime to be this many minutes from now.
     * This will return both an opaque `session_token` and `session_jwt` for this session, which will automatically be stored in the browser cookies.
     * The `session_jwt` will have a fixed lifetime of five minutes regardless of the underlying session duration, and will be automatically refreshed by the SDK in the background over time.
     * This value must be a minimum of 5 and may not exceed the maximum session duration minutes value set in the
     * {@link https://stytch.com/dashboard/sdk-configuration SDK Configuration } page of the Stytch dashboard.
     */
    session_duration_minutes: number;
};
type UnsubscribeFunction = () => void;
type OAuthGetURLOptions = {
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a user that already exists.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Login URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    login_redirect_url?: string;
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a user that does not yet exist.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Sign Up URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    signup_redirect_url?: string;
    /**
     * An optional list of custom scopes that you'd like to request from the user in addition to the ones Stytch requests by default.
     * @example Google Custom Scopes
     * ['https://www.googleapis.com/auth/gmail.compose', 'https://www.googleapis.com/auth/firebase']
     *
     * @example Facebook Custom Scopes
     * ['public_profile', 'instagram_shopping_tag_products']
     */
    custom_scopes?: string[];
};
type OAuthAuthenticateOptions = SessionDurationOptions;
type OAuthAuthenticateResponse = AuthenticateResponse & {
    /**
     * The `provider_subject` field is the unique identifier used to identify the user within a given OAuth provider.
     * Also commonly called the "sub" or "Subject field" in OAuth protocols.
     */
    provider_subject: string;
    /**
     * The `type` field denotes the OAuth identity provider that the user has authenticated with, e.g. Google, Facebook, GitHub etc.
     */
    provider_type: string;
    /**
     * If available, the `profile_picture_url` is a url of the user's profile picture set in OAuth identity the provider that the user has authenticated with, e.g. Facebook profile picture.
     */
    profile_picture_url: string;
    /**
     * If available, the `locale` is the user's locale set in the OAuth identity provider that the user has authenticated with.
     */
    locale: string;
    /**
     * The `provider_values` object lists relevant identifiers, values, and scopes for a given OAuth provider.
     * For example this object will include a provider's `access_token` that you can use to access the provider's API for a given user.
     * Note that these values will vary based on the OAuth provider in question, e.g. `id_token` may not be returned by all providers.
     */
    provider_values: {
        /**
         * The `access_token` that you may use to access the user's data in the provider's API.
         */
        access_token: string;
        /**
         * The `id_token` returned by the OAuth provider.
         * This value is similar to an access token but usually may only be used to hit a provider's OIDC endpoint, i.e. login or fetch a session, but not directly interact with the provider's API.
         * See {@link https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens here} for more details on how Microsoft treats `id_token`s.
         */
        id_token: string;
        /**
         * The `refresh_token` that you may use to refresh a user's session within the provider's API.
         */
        refresh_token: string;
        /**
         * The OAuth scopes included for a given provider.
         * See each provider's section above to see which scopes are included by default and how to add custom scopes.
         */
        scopes: string[];
    };
};
/**
 * Methods for interacting with an individual OAuth provider.
 */
interface IOAuthProvider {
    /**
     * Start an OAuth flow by redirecting the browser to one of Stytch's {@link https://stytch.com/docs/api/oauth-google-start oauth start} endpoints.
     * If enabled, this method will also generate a PKCE code_verifier and store it in localstorage on the device (See the {@link https://stytch.com/docs/oauth#guides_pkce PKCE OAuth guide} for details).
     * If your application is configured to use a custom subdomain with Stytch, it will be used automatically.
     * @example
     * const loginWithGoogle = useCallback(()=> {
     *   stytch.oauth.google.start({
     *     login_redirect_url: 'https://example.com/oauth/callback',
     *     signup_redirect_url: 'https://example.com/oauth/callback',
     *     custom_scopes: ['https://www.googleapis.com/auth/gmail.compose']
     *   })
     * }, [stytch]);
     * return (
     *   <Button onClick={loginWithGoogle}> Log in! </Button>
     * );
     *
     * @param options - An {@link OAuthGetURLOptions} object
     *
     * @returns void - the browser is redirected during this function call. You should not attempt to run any code after calling this function.
     *
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    start(options?: OAuthGetURLOptions): Promise<void>;
}
interface IHeadlessOAuthClient {
    google: IOAuthProvider;
    microsoft: IOAuthProvider;
    apple: IOAuthProvider;
    github: IOAuthProvider;
    gitlab: IOAuthProvider;
    facebook: IOAuthProvider;
    discord: IOAuthProvider;
    slack: IOAuthProvider;
    amazon: IOAuthProvider;
    bitbucket: IOAuthProvider;
    linkedin: IOAuthProvider;
    coinbase: IOAuthProvider;
    twitch: IOAuthProvider;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/oauth-authenticate oauth authenticate} endpointwhich validates the OAuth token passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * const token = new URLSearchParams(window.location.search).get('token');
     * stytch.oauth.authenticate(token, {
     *   session_duration_minutes: 60
     * }).then(...)
     *
     * @param token - The token to authenticate
     * @param options - {@link OAuthAuthenticateOptions}
     *
     * @returns A {@link OAuthAuthenticateResponse} indicating the token has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(token: string, options: OAuthAuthenticateOptions): Promise<OAuthAuthenticateResponse>;
}
type UserOnChangeCallback = (user: User | null) => void;
type UserUpdateOptions = {
    /**
     * The name of the user. If at least one name field is passed, all name fields will be updated.
     */
    name?: {
        /**
         * The first name of the user. Replaces an existing first name, if it exists.
         */
        first_name?: string;
        /**
         * The middle name(s) of the user. Replaces an existing middle name, if it exists.
         */
        middle_name?: string;
        /**
         * The last name of the user. Replaces an existing last name, if it exists.
         */
        last_name?: string;
    };
};
type UserUpdateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * The updated emails for the user.
     */
    emails: User["emails"];
    /**
     * The updated phone numbers for the user.
     */
    phone_numbers: User["phone_numbers"];
    /**
     * The updated crypto wallets for the user.
     */
    crypto_wallets: User["crypto_wallets"];
};
interface IHeadlessUserClient {
    /**
     * The asynchronous method for getting a user. This wraps the {@link https://stytch.com/docs/api/get-user get} user endpoint.
     * It fetches the user's data and refreshes the cached object if changes are detected.
     * The Stytch SDK will invoke this method automatically in the background, so you probably won't need to call this method directly.
     *
     * @returns A {@link User} object, or null if no user exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    get(): Promise<User | null>;
    /**
     * Wraps Stytch's {@link update https://stytch.com/docs/api/update-user} user endpoint. Use this method to change the user's name.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * const updateName = useCallback(() => {
     *  stytchClient.user.update({
     *    name: {
     *      first_name: 'Jane',
     *      last_name: 'Doe',
     *    },
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link UserUpdateOptions}
     *
     * @returns A {@link UserUpdateResponse} indicating the user has been updated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    update(options: UserUpdateOptions): Promise<UserUpdateResponse>;
    /**
     * The synchronous method for getting a user. This is the recommended approach. You can listen to changes with the {@link onChange onChange} method.
     * If logged in, this returns the cached user object, otherwise it returns null. This method does not refresh the user's data.
     * The `stytch-react` library provides the `useStytchUser` hook that implements these methods for you to easily access the user and listen for changes.
     *
     * @returns A {@link User} object, or null if no user exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    getSync(): User | null;
    /**
     * Allows listening to changes in the user object when using {@link getSync getSync()}.
     *
     * @param callback - Gets called whenever the user object changes. See {@link UserOnChangeCallback}.
     *
     * @returns An {@link UnsubscribeFunction} for you to call when you no longer want to listen for changes in the user object.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    onChange(callback: UserOnChangeCallback): UnsubscribeFunction;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-email delete user email} endpoint.
     * This methods cannot be used to remove all factors from a user. A user must have at least one email, phone number, or OAuth provider associated with their account at all times, otherwise they will not be able to log in again.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param emailId - ID of the email to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user email has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteEmail(emailId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-phone-number delete phone number} endpoint.
     * This methods cannot be used to remove all factors from a user. A user must have at least one email, phone number, or OAuth provider associated with their account at all times, otherwise they will not be able to log in again.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param phoneId - ID of the phone number to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user phone number has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deletePhoneNumber(phoneId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-totp delete TOTP} endpoint.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param totpId - ID of the TOTP registration to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user TOTP registration has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteTOTP(totpId: string): Promise<DeleteResponse>;
}
type MagicLinksBaseOptions = {
    /**
     * The url the user clicks from the sign-up email magic link.
     * This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and sign-up the user.
     * If this value is not passed, the default sign-up redirect URL that you set in your Dashboard is used.
     * If you have not set a default sign-up redirect URL, an error is returned.
     */
    signup_magic_link_url?: string;
    /**
     * Set the expiration for the sign-up email magic link, in minutes.
     * By default, it expires in 1 week.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    signup_expiration_minutes?: number;
    /**
     * The url the user clicks from the login email magic link.
     * This should be a url that your app receives and parses and subsequently send an API request to authenticate the magic link and log in the user.
     * If this value is not passed, the default login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_magic_link_url?: string;
    /**
     * Set the expiration for the login email magic link, in minutes.
     * By default, it expires in 1 hour.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    login_expiration_minutes?: number;
};
type MagicLinksLoginOrCreateOptions = MagicLinksBaseOptions;
type MagicLinksSendOptions = MagicLinksBaseOptions;
type MagicLinksLoginOrCreateResponse = ResponseCommon;
type MagicLinksSendResponse = ResponseCommon;
type MagicLinksAuthenticateOptions = SessionDurationOptions;
type MagicLinksAuthenticateResponse = AuthenticateResponse & {
    /**
     * The ID of the method used to send a magic link.
     */
    method_id: string;
};
interface IHeadlessMagicLinksClient {
    email: {
        /**
         * The loginOrCreate method wraps the {@link https://stytch.com/docs/api/log-in-or-create-user-by-email login_or_create} Email magic link API endpoint.
         *
         * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_send Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.loginOrCreate('sandbox@stytch.com', {
         *   login_magic_link_url: 'https://example.com/authenticate',
         *   login_expiration_minutes: 60,
         *   signup_magic_link_url: 'https://example.com/authenticate',
         *   signup_expiration_minutes: 60,
         * });
         *
         * @param email - The email of the user to send the invite magic link to.
         * @param options - {@link MagicLinksLoginOrCreateOptions}
         *
         * @returns A {@link MagicLinksLoginOrCreateResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        loginOrCreate(email: string, options?: MagicLinksLoginOrCreateOptions): Promise<MagicLinksLoginOrCreateResponse>;
        /**
         * The send method wraps the {@link https://stytch.com/docs/api/send-by-email send} Email magic link API endpoint.
         *
         * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_send Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.send('sandbox@stytch.com', {
         *   login_magic_link_url: 'https://example.com/authenticate',
         *   login_expiration_minutes: 60,
         *   signup_magic_link_url: 'https://example.com/authenticate',
         *   signup_expiration_minutes: 60,
         * });
         *
         * @param email - The email of the user to send the invite magic link to.
         * @param options - {@link MagicLinksSendOptions}
         *
         * @returns A {@link MagicLinksSendResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        send(email: string, options?: MagicLinksSendOptions): Promise<MagicLinksSendResponse>;
    };
    /**
     * The Authenticate method wraps the {@link https://stytch.com/docs/api/authenticate-magic-link authenticate}
     * Magic link API endpoint which validates the magic link token passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_authenticate Stytch Docs} for a complete reference.
     *
     * @example
     * const currentLocation = new URL(window.location.href);
     * const token = currentLocation.searchParams.get('token');
     * stytch.magicLinks.authenticate(token, {
     *   session_duration_minutes: 60,
     * });
     *
     * @param token - The magic link token from the token query parameter in the URL.
     * @param options - {@link MagicLinksLoginOrCreateOptions}
     *
     * @returns A {@link MagicLinksAuthenticateResponse} indicating that magic link has been authenticated and the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(token: string, options: MagicLinksAuthenticateOptions): Promise<MagicLinksAuthenticateResponse>;
}
type OTPCodeOptions = {
    /**
     * Set the expiration for the one-time passcode, in minutes. The minimum expiration is 1 minute and the maximum is 10 minutes. The default expiration is 2 minutes.
     */
    expiration_minutes: number;
};
type OTPAuthenticateOptions = {
    /**
     * Set the session lifetime to be this many minutes from now.
     * This value must be a minimum of 5 and may not exceed the `maximum session duration minutes` value set in the {@link https://stytch.com/dashboard/sdk-configuration SDK Configuration} page of the Stytch dashboard.
     * A successful authentication will continue to extend the session this many minutes.
     */
    session_duration_minutes: number;
};
type OTPsBaseResponse = ResponseCommon & {
    /**
     * The ID of the method used to send a one-time passcode.
     */
    method_id: string;
};
type OTPsLoginOrCreateResponse = OTPsBaseResponse;
type OTPsSendResponse = OTPsBaseResponse;
type OTPsAuthenticateResponse = AuthenticateResponse & {
    /**
     * The ID of the method used to send a one-time passcode.
     */
    method_id: string;
};
interface IHeadlessOTPsClient {
    sms: {
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-sms login_or_create} via SMS API endpoint. Call this method to send an SMS passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.sms.loginOrCreate('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(phone_number: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/send-otp-by-sms send} via SMS API endpoint. Call this method to send an SMS passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.sms.send('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(phone_number: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    whatsapp: {
        /**
         *  Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-whatsapp login_or_create} via WhatsApp API endpoint. Call this method to send a WhatsApp passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.whatsapp.loginOrCreate('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(phone_number: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/whatsapp-send send} via WhatsApp API endpoint. Call this method to send an WhatsApp passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.whatsapp.send('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(phone_number: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    email: {
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-email login_or_create} via email API endpoint. Call this method to send an email passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.email.loginOrCreate('sandbox@stytch.com', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param email - The email address of the user to send the one-time passcode to. You may use sandbox@stytch.com to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(email: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/send-otp-by-email send} via Email API endpoint. Call this method to send an email passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.email.send('sandbox@stytch.com', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param email - The email address of the user to send the one-time passcode to. You may use sandbox@stytch.com to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(email: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    /**
     * The authenticate method wraps the {@link https://stytch.com/docs/api/authenticate-otp authenticate} one-time passcode API method which validates the code passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link session cookies https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * const [code, setCode] = useState('');
     *
     * const method_id = "phone-number-test-d5a3b680-e8a3-40c0-b815-ab79986666d0"
     * // returned from calling loginOrCreate for OTPs on SMS, WhatsApp or Email
     *
     * const authenticate = useCallback((e) => {
     *  e.preventDefault();
     *  stytchClient.otps.authenticate(code, method_id, {
     *    session_duration_minutes: 60,
     *  });
     * }, [stytchClient, code]);
     *
     * const handleChange = useCallback((e) => {
     *  setCode(e.target.value);
     * }, []);
     * ```
     *
     * @param otp - The code to authenticate.
     * @param method_id - The ID of the method used to send a one-time passcode.
     * @param options - {@link OTPAuthenticateOptions}
     *
     * @returns A {@link OTPsAuthenticateResponse} indicating the one-time passcode method has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(otp: string, method_id: string, options?: OTPAuthenticateOptions): Promise<OTPsAuthenticateResponse>;
}
type CryptoWalletAuthenticateStartOptions = {
    /**
     * The address to authenticate.
     */
    crypto_wallet_address: string;
    /**
     * The type of wallet to authenticate. Currently `ethereum` and `solana` are supported.
     */
    crypto_wallet_type: string;
};
type CryptoWalletAuthenticateStartResponse = ResponseCommon & {
    /**
     * The challenge to be signed by the user's wallet.
     */
    challenge: string;
};
type CryptoWalletAuthenticateOptions = SessionDurationOptions & {
    /**
     * The address to authenticate.
     */
    crypto_wallet_address: string;
    /**
     * The type of wallet to authenticate. Currently `ethereum` and `solana` are supported.
     */
    crypto_wallet_type: string;
    /**
     * The signature from the message.
     */
    signature: string;
};
type CryptoWalletAuthenticateResponse = AuthenticateResponse;
interface IHeadlessCryptoWalletClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/crypto-wallet-authenticate-start authenticate_start} crypto wallet endpoint. Call this method to load the challenge data. Pass this challenge to your user's wallet for signing.
     *
     * @example
     * ```
     * // Request user's address
     * const [crypto_wallet_address] = await ethereum.request({
     *   method: 'eth_requestAccounts',
     * });
     *
     * // Ask Stytch to generate a challenge for the user
     * const { challenge } = await stytch.cryptoWallets.authenticateStart({
     *   crypto_wallet_address: crypto_wallet_address,
     *   crypto_wallet_type: 'ethereum',
     * });
     * ```
     * @param options - {@link CryptoWalletAuthenticateStartOptions}
     *
     * @returns A {@link CryptoWalletAuthenticateStartResponse} containing a challenge to be passed to the user's wallet for signing.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticateStart(options: CryptoWalletAuthenticateStartOptions): Promise<CryptoWalletAuthenticateStartResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/crypto-wallet-authenticate authenticate} crypto wallet endpoint. Call this method after the user signs the challenge to validate the signature.
     * If this method succeeds and the user is not already logged in, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * If the user is already logged in, the crypto wallet will be added to the `user.crypto_wallets[]` array and associated with user's existing session as an `authentication_factor`.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * // Ask the user to sign the challenge
     * const signature = await ethereum.request({
     *   method: 'personal_sign',
     *   params: [challenge, crypto_wallet_address],
     * });
     *
     * // Authenticate the signature
     * stytch.cryptoWallets.authenticate({
     *  crypto_wallet_address: crypto_wallet_address,
     *  crypto_wallet_type: 'ethereum',
     *  signature: signature,
     *  session_duration_minutes: 60,
     * });
     * ```
     *
     * @param options - {@link CryptoWalletAuthenticateOptions}
     *
     * @returns A {@link CryptoWalletAuthenticateResponse} indicating the user has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: CryptoWalletAuthenticateOptions): Promise<CryptoWalletAuthenticateResponse>;
}
type TOTPCreateOptions = {
    /**
     * The expiration for the TOTP instance. If the newly created TOTP is not authenticated within this time frame the TOTP will be unusable. Defaults to 60 (1 hour) with a minimum of 5 and a maximum of 1440.
     */
    expiration_minutes: number;
};
type TOTPCreateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
    /**
     * The TOTP secret key shared between the authenticator app and the server used to generate TOTP codes.
     */
    secret: string;
    /**
     * The QR code image encoded in base64.
     */
    qr_code: string;
    /**
     * The recovery codes used to authenticate the user without an authenticator app.
     */
    recovery_codes: string[];
};
type TOTPAuthenticateOptions = SessionDurationOptions & {
    /**
     * The TOTP code to authenticate. The TOTP code should consist of 6 digits.
     */
    totp_code: string;
};
type TOTPAuthenticateResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
};
type TOTPRecovery = {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
    /**
     * Indicates whether or not the TOTP registration has been verified by the user.
     */
    verified: boolean;
    /**
     * The recovery codes for the TOTP registration.
     */
    recovery_codes: string[];
};
type TOTPRecoveryCodesResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * See {@link TOTPRecovery}.
     */
    totps: TOTPRecovery;
};
type TOTPRecoverOptions = SessionDurationOptions & {
    /**
     * The recovery code to authenticate.
     */
    recovery_code: string;
};
type TOTPRecoverResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
};
interface IHeadlessTOTPClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-create create} endpoint. Call this method to create a new TOTP instance for a user. The user can use the authenticator application of their choice to scan the QR code or enter the secret.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * stytchClient.totps.create({ expiration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPCreateOptions}
     *
     * @returns A {@link TOTPCreateResponse} indicating a new TOTP instance has been created.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    create(options: TOTPCreateOptions): Promise<TOTPCreateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-authenticate authenticate} endpoint. Call this method to authenticate a TOTP code entered by a user.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * stytch.totps.authenticate({ totp_code: '123456', session_duration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPAuthenticateOptions}
     *
     * @returns A {@link TOTPAuthenticateResponse} indicating the TOTP code has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: TOTPAuthenticateOptions): Promise<TOTPAuthenticateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-get-recovery-codes recovery_codes} endpoint. Call this method to retrieve the recovery codes for a TOTP instance tied to a user.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * stytchClient.totps.recoveryCodes();
     * ```
     *
     * @returns A {@link TOTPRecoveryCodesResponse} containing the TOTP recovery codes tied to the user.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    recoveryCodes(): Promise<TOTPRecoveryCodesResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-recover recover} endpoint. Call this method to authenticate a recovery code for a TOTP instance.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * stytch.totps.recover({ recovery_code: 'xxxx-xxxx-xxxx', session_duration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPRecoverOptions}
     *
     * @returns A {@link TOTPRecoverResponse} indicating the TOTP recovery code has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    recover(options: TOTPRecoverOptions): Promise<TOTPRecoverResponse>;
}
type WebAuthnRegisterStartOptions = {
    /**
     * The domain for the WebAuthn registration. Defaults to `window.location.hostname`.
     */
    domain?: string;
    /**
     * The requested authenticator type of the WebAuthn device. The two valid values are `platform` and `cross-platform`. If no value passed, we assume both values are allowed.
     */
    authenticator_type?: "platform" | "cross-platform";
};
type WebAuthnRegisterResponse = ResponseCommon & {
    /**
     * The user ID of an active user the WebAuthn registration is for.
     */
    user_id: string;
    /**
     * A unique ID that identifies a specific WebAuthn registration.
     */
    webauthn_registration_id: string;
};
type WebAuthnAuthenticateStartOptions = SessionDurationOptions & {
    /**
     * The domain for the WebAuthn registration.
     */
    domain?: string;
};
type WebAuthnAuthenticateResponse = AuthenticateResponse & {
    /**
     * A unique ID that identifies a specific WebAuthn registration.
     */
    webauthn_registration_id: string;
};
interface IHeadlessWebAuthnClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/webauthn-register-start register_start} and {@link https://stytch.com/docs/api/webauthn-register register} WebAuthn endpoints and the {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create navigator.credentials} web API. Call this method to prompt the user to enroll a new WebAuthn factor and save the factor in Stytch.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * const registerWebAuthn = useCallback(() => {
     *  stytchClient.register({
     *    domain: 'subdomain.example.com',
     *    authenticator_type: 'platform'
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link WebAuthnRegisterStartOptions}
     *
     * @returns A {@link WebAuthnRegisterResponse} indicating WebAuthn has been registered.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    register(options?: WebAuthnRegisterStartOptions): Promise<WebAuthnRegisterResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/webauthn-authenticate-start authenticate_start} and {@link https://stytch.com/docs/api/webauthn-authenticate authenticate} WebAuthn endpoints and the navigator.credentials web API.
     * Call this method to prompt the user to authenticate an existing WebAuthn registration.
     * In order to use these methods, the user must have already logged in with a primary method - OAuth, one-time passcodes, or magic links.
     * If this method succeeds, the WebAuthn credential will be added to the user's existing session as an `authentication_factor`, the user will be logged in, granted an active session, and the session cookies will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * const authenticateWebAuthn = useCallback(() => {
     *  stytchClient.webauthn.authenticate({
     *    domain: 'subdomain.example.com',
     *    session_duration_minutes: 60,
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link WebAuthnAuthenticateStartOptions}
     *
     * @returns A {@link WebAuthnAuthenticateResponse} indicating the WebAuthn registration has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: WebAuthnAuthenticateStartOptions): Promise<WebAuthnAuthenticateResponse>;
}
type PasswordCreateOptions = SessionDurationOptions & {
    /**
     * The email of the new user.
     */
    email: string;
    /**
     * The password for the new user.
     */
    password: string;
};
type PasswordCreateResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific email address in the Stytch API.
     * The `email_id` is used when you need to operate on a specific user's email address,
     * e.g. to delete the email address from the Stytch user.
     */
    email_id: string;
};
type PasswordAuthenticateOptions = SessionDurationOptions & {
    /**
     * The email of the user.
     */
    email: string;
    /**
     * The password for the user.
     */
    password: string;
};
type PasswordAuthenticateResponse = AuthenticateResponse;
type PasswordResetByEmailStartOptions = {
    /**
     * The email of the user that requested the password reset.
     */
    email: string;
    /**
     * The url that the user clicks from the password reset email to skip resetting their password and directly login.
     * This should be a url that your app receives, parses, and subsequently sends an API request to the magic link authenticate endpoint to complete the login process without reseting their password.
     * If this value is not passed, the login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_redirect_url?: string;
    /**
     * Set the expiration for the login email magic link, in minutes.
     * By default, it expires in 1 hour.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    login_expiration_minutes?: number;
    /**
     * The url that the user clicks from the password reset email to finish the reset password flow.
     * This should be a url that your app receives and parses before showing your app's reset password page.
     * After the user submits a new password to your app, it should send an API request to complete the password reset process.
     * If this value is not passed, the default reset password redirect URL that you set in your Dashboard is used.
     * If you have not set a default reset password redirect URL, an error is returned.
     */
    reset_password_redirect_url?: string;
    /**
     * Set the expiration for the password reset, in minutes.
     * By default, it expires in 30 minutes.
     * The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     */
    reset_password_expiration_minutes?: number;
};
type PasswordResetByEmailStartResponse = ResponseCommon;
type PasswordResetByEmailOptions = SessionDurationOptions & {
    /**
     * The token to authenticate.
     */
    token: string;
    /**
     * The new password for the user.
     */
    password: string;
};
type PasswordResetByEmailResponse = AuthenticateResponse;
type PasswordResetByExistingPasswordOptions = SessionDurationOptions & {
    /**
     * The user's email.
     */
    email: string;
    /**
     * The user's existing password.
     */
    existing_password: string;
    /**
     * The new password for the user.
     */
    new_password: string;
};
type PasswordResetByExistingPasswordResponse = AuthenticateResponse;
type PasswordResetBySessionOptions = {
    password: string;
};
type PasswordResetBySessionResponse = AuthenticateResponse;
type PasswordStrengthCheckOptions = {
    /**
     * The email associated with the password. Provide this for a more accurate strength check.
     */
    email?: string;
    /**
     * The password to strength check.
     */
    password: string;
};
type PasswordStrengthCheckResponse = ResponseCommon & {
    /**
     * Whether or not the password is considered valid and secure.
     * Read more about password validity {@link https://stytch.com/docs/api/password-strength-check in our docs}.
     */
    valid_password: boolean;
    /**
     * The score of the password as determined by {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    score: number;
    /**
     * Determines if the password has been breached using {@link https://haveibeenpwned.com/ HaveIBeenPwned}.
     */
    breached_password: boolean;
    /**
     * Feedback for how to improve the password's strength using {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    feedback: {
        suggestions: string[];
        warning: string;
    };
};
interface IHeadlessPasswordClient {
    /**
     * The Create method wraps the {@link https://stytch.com/docs/api/password-create Create} Password API endpoint.
     * If a user with this email already exists in the project, this API will return an error.
     * Existing passwordless users who wish to create a password need to go through the reset password flow.
     *
     * This endpoint will return an error if the password provided does not meet our strength requirements,
     * which you can check beforehand with the {@link IHeadlessPasswordClient#strengthCheck password strength} endpoint.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * const {valid_password} = await stytch.passwords.strengthCheck({ email, password });
     * if (valid_password) {
     *   stytch.passwords.create({ email, password, session_duration_minutes: 60 });
     * }
     *
     * @param options - {@link PasswordCreateOptions}
     *
     * @returns A {@link PasswordCreateResponse} indicating the user has been created and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    create(options: PasswordCreateOptions): Promise<PasswordCreateResponse>;
    /**
     * The Authenticate method wraps the {@link https://stytch.com/docs/api/password-authenticate Authenticate} Password API endpoint.
     * This endpoint verifies that the user has a password currently set, and that the entered password is correct.
     *
     * There are cases where this endpoint will return a `reset_password` error even if the password entered is correct.
     * View our {@link https://stytch.com/docs/api/password-authenticate API Docs} for complete details.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * stytch.passwords.authenticate({
     *   email: 'sandbox@stytch.com',
     *   password: aVerySecurePassword,
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link PasswordAuthenticateOptions}
     *
     * @returns A {@link PasswordAuthenticateResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(options: PasswordAuthenticateOptions): Promise<PasswordAuthenticateResponse>;
    /**
     * The resetByEmailStart method wraps the {@link https://stytch.com/docs/api/password-email-reset-start Reset By Email Start} Password API endpoint.
     * This endpoint initiates a password reset for the email address provided.
     * This will trigger an email to be sent to the address, containing a magic link that will allow them to set a new password and authenticate.
     *
     * @example
     * stytch.passwords.resetByEmailStart({
     *   email: 'sandbox@stytch.com',
     *   reset_password_redirect_url: 'https://example.com/login/reset',
     *   reset_password_expiration_minutes: 10,
     *   login_redirect_url: 'https://example.com/login/authenticate',
     * });
     *
     * @param options - {@link PasswordResetByEmailStartOptions}
     *
     * @returns A {@link PasswordResetByEmailStartResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmailStart(options: PasswordResetByEmailStartOptions): Promise<PasswordResetByEmailStartResponse>;
    /**
     * The resetByEmail method wraps the {@link https://stytch.com/docs/api/password-email-reset Reset By Email} Password API endpoint.
     * This endpoint the userâ€™s password and authenticate them.
     * This endpoint checks that the magic link token is valid, hasn't expired, or already been used.
     * The provided password needs to meet our password strength requirements, which can be checked in advance with the {@link IHeadlessPasswordClient#strengthCheck password strength} endpoint.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * const currentLocation = new URL(window.location.href);
     * const token = currentLocation.searchParams.get('token');
     * stytch.passwords.resetByEmail({
     *   token,
     *   email: 'sandbox@stytch.com',
     *   password: aVerySecurePassword,
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link PasswordResetByEmailOptions}
     *
     * @returns A {@link PasswordResetByEmailResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmail(options: PasswordResetByEmailOptions): Promise<PasswordResetByEmailResponse>;
    /**
     * The strengthCheck method wraps the {@link https://stytch.com/docs/api/password-strength-check Strength Check} Password API endpoint.
     * This endpoint allows you to check whether or not the userâ€™s provided password is valid,
     * and to provide feedback to the user on how to increase the strength of their password.
     *
     * @example
     * const {valid_password, feedback} = await stytch.passwords.strengthCheck({ email, password });
     * if (!valid_password) {
     *   throw new Error('Password is not strong enough: ' + feedback.warning);
     * }
     *
     * @param options - {@link PasswordStrengthCheckOptions}
     *
     * @returns A {@link PasswordStrengthCheckResponse} containing password strength feedback.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    strengthCheck(options: PasswordStrengthCheckOptions): Promise<PasswordStrengthCheckResponse>;
}
/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */
declare enum Products {
    emailMagicLinks = "emailMagicLinks",
    oauth = "oauth",
    otp = "otp",
    crypto = "crypto",
    passwords = "passwords"
}
/**
 * The options for email magic links. This is required if you've enabled the `emailMagicLinks` product
 * in your configuration.
 */
type EmailMagicLinksOptions = {
    loginRedirectURL: string;
    loginExpirationMinutes?: number;
    signupRedirectURL: string;
    signupExpirationMinutes?: number;
    createUserAsPending?: boolean;
    /**
     * @param domainHint - An optional hint indicating what domain the email will be sent from.
     * This field is only required if your project uses more than one custom domain to send emails.
     */
    domainHint?: string;
};
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, and `Slack`.
 */
declare enum OAuthProviders {
    Google = "google",
    Microsoft = "microsoft",
    Apple = "apple",
    Github = "github",
    GitLab = "gitlab",
    Facebook = "facebook",
    Discord = "discord",
    Slack = "slack",
    Amazon = "amazon",
    Bitbucket = "bitbucket",
    LinkedIn = "linkedin",
    Coinbase = "coinbase",
    Twitch = "twitch"
}
/**
 * For Google One Tap, we support two different position options:
 * `embedded` will display Google One Tap within the existing JavaScript SDK login form
 * `floating` will display the One Tap prompt in the top right corner.
 */
declare enum OneTapPositions {
    embedded = "embedded",
    floating = "floating"
}
type ProviderOptions = {
    type: OAuthProviders;
    one_tap?: boolean;
    position?: OneTapPositions;
    custom_scopes?: string[];
};
/**
 * An array of OAuth providers you wish to use. Each Provider is an object with a type key that
 * determines the type of provider. Each Provider accepts an optional custom_scopes array of
 * scopes that Stytch will request for your application in addition to the base set of scopes
 * required for login. The order of the providers in the array determines the order of the
 * rendered buttons.
 */
type ProvidersOptions = Array<ProviderOptions>;
/**
 * The options for oAuth. This is required if you've enabled the `oauth` product
 * in your configuration.
 */
type OAuthOptions = {
    loginRedirectURL?: string;
    signupRedirectURL?: string;
    providers: ProvidersOptions;
};
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */
declare enum OTPMethods {
    SMS = "sms",
    WhatsApp = "whatsapp",
    Email = "email"
}
/**
 * The options for One Time Passcodes. This is required if you've enabled the `otp` product
 * in your configuration.
 */
type OtpOptions = {
    methods: Array<OTPMethods>;
    expirationMinutes: number;
};
/**
 * The options for passwords. This is required if you've enabled the `passwords` product
 * in your configuration.
 */
type PasswordOptions = {
    loginRedirectURL: string;
    loginExpirationMinutes?: number;
    resetPasswordRedirectURL: string;
    resetPasswordExpirationMinutes?: number;
};
/**
 * The options for Session Management. If you are using the UI components,
 * we also create a session for users when they log in.
 */
type SessionOptions = {
    sessionDurationMinutes: number;
};
/**
 * The configuration object for the Stytch SDK's UI
 */
type StytchLoginConfig = {
    /**
     * The products array allows you to specify the authentication methods that you would like to
     * expose to your users. The order of the products that you include here will also be the order
     * in which they appear in the login form,
     */
    products: Products[];
    emailMagicLinksOptions?: EmailMagicLinksOptions;
    oauthOptions?: OAuthOptions;
    otpOptions?: OtpOptions;
    sessionOptions?: SessionOptions;
    passwordOptions?: PasswordOptions;
};
type AnalyticsEvent = {
    name: "sdk_instance_instantiated";
    details: {
        event_callback_registered: boolean;
        error_callback_registered: boolean;
        success_callback_registered: boolean;
    };
} | {
    name: "render_login_screen";
    details: {
        options: StytchLoginConfig;
    };
} | {
    name: "start_oauth_flow";
    details: {
        provider_type: string;
        custom_scopes?: string[];
        cname_domain: string | null;
        pkce: boolean;
    };
};
type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
type BootstrapData = {
    displayWatermark: boolean;
    cnameDomain: string | null;
    emailDomains: string[];
    captchaSettings: {
        enabled: false;
    } | {
        enabled: true;
        siteKey: string;
    };
    pkceRequiredForEmailMagicLinks: boolean;
    pkceRequiredForPasswordResets: boolean;
    pkceRequiredForOAuth: boolean;
};
/**
 * One Tap related code
 */
type EnvironmentOptions = {
    endpoints?: {
        sdkBackendURL: string;
        liveAPIURL: string;
        testAPIURL: string;
        clientsideServicesIframeURL: string;
    };
};
type SessionPersistenceOptions = {
    // TODO: These values are for internal use only so far
    // and are not part of the public API. Do we want to camelCase or snake_case them?
    cookieOptions?: {
        opaqueTokenCookieName: string;
        jwtCookieName: string;
    };
};
type StytchClientOptions = SessionPersistenceOptions & EnvironmentOptions;
declare function loadESModule<T>(url: string, moduleFromGlobalScope: () => T): Promise<T>;
declare const checkPublicToken: (publicToken: unknown) => void;
declare const checkNotSSR: (clientName: "StytchUIClient" | "StytchHeadlessClient") => void;
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * An ultralightweight wrapper around console.log.
 * In the future, the logger might be passed in from the customer,
 * or the level might be configurable.
 */
declare const logger: {
    debug: (...args: any[]) => boolean;
    log: (...args: any[]) => void;
    warn: (...args: any[]) => void;
    error: (...args: any[]) => void;
};
declare const isTestPublicToken: (token: string) => boolean;
type DeepEqualOpts = {
    KEYS_TO_EXCLUDE?: string[];
};
declare const createDeepEqual: ({ KEYS_TO_EXCLUDE }?: DeepEqualOpts) => (a: any, b: any) => boolean;
/**
 * Normalizes an es5 promise with a .then(onSuccess, onFailure) signature to
 * the es6 .then().catch() signature
 */
declare const normalizePromiseLike: <T>(prom: PromiseLike<T>) => Promise<T>;
declare const createEventId: () => string;
declare const createAppSessionId: () => string;
declare const createPersistentId: () => string;
declare const validate: (methodName: string) => {
    isString: (fieldName: string, value: string) => any;
    isOptionalString: (fieldName: string, value: string | undefined) => any;
    isStringArray: (fieldName: string, value: string[]) => any;
    isNumber: (fieldName: string, value: number) => any;
    isOptionalNumber: (fieldName: string, value: number | undefined) => any;
};
declare const isPhoneMethod: (selectionMethod: string) => boolean;
declare const isEmailMethod: (selectionMethod: string) => boolean;
declare const removeResponseCommon: <T extends ResponseCommon>({ 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
request_id, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
status_code, ...rest }: T) => Omit<T, keyof ResponseCommon>;
type WithUser<T> = T & {
    __user: User & ResponseCommon;
};
declare const omitUser: <T extends {
    __user: User & ResponseCommon;
}>(resp: T) => Omit<T, "__user">;
interface StorageResponse {
    success: boolean;
    message?: string;
}
interface IStorageClient {
    getData: (key: string) => Promise<string | null>;
    setData: (key: string, data: string) => Promise<StorageResponse>;
    clearData: (key: string) => Promise<StorageResponse>;
}
type SDKRequestMethodAndBody = {
    method: "GET" | "DELETE";
    body?: null;
} | {
    method: "POST" | "PUT";
    body?: Record<string, unknown>;
};
type SDKRequestInfo = SDKRequestMethodAndBody & {
    url: string;
    errorMessage: string;
    additionalMetadata?: Record<string, string>;
};
interface SDKTelemetry {
    event_id: string;
    app_session_id: string;
    persistent_id: string;
    client_sent_at: string;
    timezone: string;
    // Logged in user data
    // Why don't we generate this from the session_token in the auth header?
    // - We don't want to tie analytics ingest to session validation. There's no need to put
    //   that kind of pressure on API, and ingest could be moved to somewhere that doesn't
    //   have the ability to validate tokens
    // - For bulk event batches, we want to keep track of whether or not a user was logged
    //   in at each event. If we have 10 events, the user logs in at event 5, then they'll have
    //   a token when they log the batch, but we want to know that they were not logged in for the
    //   first 4 events
    stytch_user_id?: string;
    stytch_session_id?: string;
    // Versioning
    app: {
        identifier: string;
        version?: string;
    };
    os?: {
        identifier?: string;
        version?: string;
    };
    device?: {
        model?: string;
        screen_size?: string;
    };
    sdk: {
        identifier: string;
        version: string;
    };
}
interface INetworkClient {
    createTelemetryBlob(additionalMetadata?: SDKRequestInfo["additionalMetadata"]): SDKTelemetry;
    fetchSDK: <T extends ResponseCommon>(info: SDKRequestInfo) => Promise<T>;
    logEvent<E extends AnalyticsEvent>({ name, details, error }: {
        name: E["name"];
        details: E["details"];
        error?: {
            error_code?: string;
            error_description?: string;
            http_status_code?: string;
        };
    }): void;
    updateSessionToken: (sessionToken: string | null) => void;
}
type SDKBaseRequestInfo = {
    basicAuthHeader: string;
    xSDKClientHeader: string;
    xSDKParentHostHeader?: string;
    body: SDKRequestInfo["body"];
    method: SDKRequestInfo["method"];
    errorMessage: SDKRequestInfo["errorMessage"];
    finalURL: string;
};
declare function baseFetchSDK<T extends ResponseCommon>({ method, errorMessage, finalURL, basicAuthHeader, xSDKClientHeader, xSDKParentHostHeader, body }: SDKBaseRequestInfo): Promise<T>;
type ProofkeyPair = {
    code_challenge: string;
    code_verifier: string;
};
interface IPKCEManager {
    startPKCETransaction(): Promise<ProofkeyPair>;
    getPKPair(): ProofkeyPair | undefined;
    clearPKPair(): void;
}
type SubscriberFunction<T> = (value: T | null) => void;
type Subscribers<T> = {
    [id: string]: SubscriberFunction<T>;
};
declare class SubscriptionDataLayer {
    private _publicToken;
    private _storageClient;
    private _networkClient;
    session: Session | null;
    user: User | null;
    session_token: string | null;
    session_jwt: string | null;
    sessionSubscriptions: Subscribers<Session>;
    userSubscriptions: Subscribers<User>;
    constructor(_publicToken: string, _storageClient: IStorageClient, _networkClient: INetworkClient);
    syncToLocalStorage(): void;
    syncFromLocalStorage: () => Promise<StateDiff | null>;
}
// Case 1: After an /authenticate call we get a new user, session, and token
type StateDiffLoggedIn = {
    session: Session;
    session_token: string;
    session_jwt: string;
    user: User;
};
// Case 2: After a logout we null everything
type StateDiffLoggedOut = {
    session: null;
    session_token: null;
    session_jwt: null;
    user: null;
};
type StateDiff = StateDiffLoggedIn | StateDiffLoggedOut;
interface ISubscriptionService {
    updateState(stateDiff: StateDiff): void;
    updateUser(user: User): void;
    destroyState(): void;
    getSession(): Session | null;
    getTokens(): SessionTokens | null;
    subscribeToSession(callback: SubscriberFunction<Session | null>): UnsubscribeFunction;
    getUser(): User | null;
    subscribeToUser(callback: SubscriberFunction<User | null>): UnsubscribeFunction;
    syncFromDeviceStorage(onCompleteCallback: () => void): void;
}
declare class SubscriptionService implements ISubscriptionService {
    private _networkClient;
    private _datalayer;
    constructor(publicToken: string, storageClient: IStorageClient, _networkClient: INetworkClient);
    syncFromDeviceStorage(onCompleteCallback: () => void): void;
    getSession(): Session | null;
    getTokens(): SessionTokens | null;
    destroyState(): void;
    _updateStateInternal(stateDiff: StateDiff): void;
    updateState(stateDiff: StateDiff): void;
    updateUser(user: User): void;
    subscribeToSession(callback: SubscriberFunction<Session>): UnsubscribeFunction;
    getUser(): User | null;
    subscribeToUser(callback: SubscriberFunction<User>): UnsubscribeFunction;
}
interface ISessionManager {
    performBackgroundRefresh: () => void;
    cancelBackgroundRefresh: () => void;
}
declare class SessionManager implements ISessionManager {
    private _subscriptionService;
    private _headlessSessionClient;
    // Three minutes
    private static REFRESH_INTERVAL_MS;
    // When testing - it's often more useful to set to a shorter duration
    // private static REFRESH_INTERVAL_MS = 1000 * 3;
    private timeout;
    constructor(_subscriptionService: ISubscriptionService, _headlessSessionClient: IHeadlessSessionClient);
    /**
     * The core logic of the session refresh recursive trampoline
     * - Refreshes the currently issued session
     * - Schedules a future refresh if successful
     */
    performBackgroundRefresh(): void;
    private scheduleBackgroundRefresh;
    cancelBackgroundRefresh(): void;
    /**
     * We need to listen to a few types of events:
     * - If the user logs in via invoking a .authenticate() call, we should start the background worker
     * - If the user steps up their authentication via another .authenticate call(), we should restart the background worker
     * - If the user logs out, we should terminate the worker
     * - We should ignore session changes that we ourselves caused - so if we already have a timeout, leave it be!
     */
    private _onSessionChange;
    private _reauthenticateWithBackoff;
    // We start with a backoff of 2000ms and increase exponentially to 32000ms (+/- 175 ms for jitter)
    // Total time waiting should be ~62000ms
    // These numbers were picked pretty arbitrarily, but they satisfy the constraint
    // that sum(timeouts) should be well under 2 minutes
    // so we can run all the attempts before the 5m JWT expiration
    // allocating ~50s for p9999 network latency across 4 retries
    static timeoutForAttempt(count: number): number;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isUnrecoverableRecoverableError(error: any): boolean;
}
declare const DEFAULT_MAX_BATCH_SIZE = 15;
declare const DEFAULT_INTERVAL_DURATION_MS = 800;
type EventLoggerArgs = {
    maxBatchSize: number;
    intervalDurationMs: number;
    logEventURL: string;
};
declare class EventLogger {
    private maxBatchSize;
    private logEventURL;
    private batch;
    constructor(args: EventLoggerArgs);
    logEvent(telemetry: SDKTelemetry, event: Record<string, unknown>): void;
    flush(): Promise<void>;
}
declare class HeadlessUserClient implements IHeadlessUserClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService);
    get: () => Promise<User>;
    getSync: () => User | null;
    update: (options: UserUpdateOptions) => Promise<Omit<WithUser<UserUpdateResponse>, "__user">>;
    deleteEmail: (emailId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deletePhoneNumber: (phoneId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deleteTOTP: (totpId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deleteWebauthnRegistration: (webAuthnId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    onChange: (callback: UserOnChangeCallback) => UnsubscribeFunction;
}
declare class HeadlessSessionClient implements IHeadlessSessionClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService);
    getSync: () => Session | null;
    onChange: (callback: SessionOnChangeCallback) => UnsubscribeFunction;
    revoke: () => Promise<ResponseCommon>;
    authenticate: (options?: SessionAuthenticateOptions) => Promise<Omit<WithUser<AuthenticateResponse>, "__user">>;
    getTokens(): SessionTokens | null;
}
type DynamicConfig = Promise<{
    pkceRequiredForEmailMagicLinks: boolean;
}>;
declare class HeadlessMagicLinksClient implements IHeadlessMagicLinksClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _config;
    private executeRecaptcha;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService, _pkceManager: IPKCEManager, _config?: DynamicConfig, executeRecaptcha?: () => Promise<string | undefined>);
    private getCodeChallenge;
    email: {
        loginOrCreate: (email: string, options?: MagicLinksLoginOrCreateOptions) => Promise<ResponseCommon>;
        send: (email: string, options?: MagicLinksSendOptions) => Promise<ResponseCommon>;
    };
    authenticate: (token: string, options: MagicLinksAuthenticateOptions) => Promise<Omit<WithUser<MagicLinksAuthenticateResponse>, "__user">>;
}
declare class HeadlessOTPClient implements IHeadlessOTPsClient {
    private _networkClient;
    private _subscriptionService;
    private executeRecaptcha;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService, executeRecaptcha?: () => Promise<string | undefined>);
    sms: {
        loginOrCreate: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsLoginOrCreateResponse>;
        send: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsSendResponse>;
    };
    whatsapp: {
        loginOrCreate: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsLoginOrCreateResponse>;
        send: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsSendResponse>;
    };
    email: {
        loginOrCreate: (email: string, options: OTPCodeOptions) => Promise<OTPsLoginOrCreateResponse>;
        send: (email: string, options: OTPCodeOptions) => Promise<OTPsSendResponse>;
    };
    authenticate: (code: string, method_id: string, options: OTPAuthenticateOptions) => Promise<Omit<WithUser<OTPsAuthenticateResponse>, "__user">>;
}
type DynamicConfig$0 = Promise<{
    cnameDomain: null | string;
    pkceRequiredForOAuth: boolean;
}>;
type Config = {
    publicToken: string;
    testAPIURL: string;
    liveAPIURL: string;
};
declare class HeadlessOAuthClient implements IHeadlessOAuthClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _dynamicConfig;
    private _config;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService, _pkceManager: IPKCEManager, _dynamicConfig: DynamicConfig$0, _config: Config);
    google: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    apple: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    microsoft: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    github: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    gitlab: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    facebook: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    discord: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    slack: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    amazon: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    bitbucket: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    linkedin: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    coinbase: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    twitch: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes }?: OAuthGetURLOptions) => Promise<void>;
    };
    authenticate(token: string, options: OAuthAuthenticateOptions): Promise<Omit<WithUser<OAuthAuthenticateResponse>, "__user">>;
    private getBaseApiUrl;
    private startOAuthFlow;
}
declare class HeadlessCryptoWalletClient implements IHeadlessCryptoWalletClient {
    private _networkClient;
    private _subscriptionService;
    private executeRecaptcha;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService, executeRecaptcha?: () => Promise<string | undefined>);
    authenticateStart(options: CryptoWalletAuthenticateStartOptions): Promise<CryptoWalletAuthenticateStartResponse>;
    authenticate(options: CryptoWalletAuthenticateOptions): Promise<CryptoWalletAuthenticateResponse>;
}
declare class HeadlessTOTPClient implements IHeadlessTOTPClient {
    _networkClient: INetworkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService);
    create(options: TOTPCreateOptions): Promise<TOTPCreateResponse>;
    authenticate(options: TOTPAuthenticateOptions): Promise<TOTPAuthenticateResponse>;
    recoveryCodes(): Promise<TOTPRecoveryCodesResponse>;
    recover(options: TOTPRecoverOptions): Promise<Omit<WithUser<TOTPRecoverResponse>, "__user">>;
}
declare class HeadlessWebAuthnClient implements IHeadlessWebAuthnClient {
    _networkClient: INetworkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService);
    register(options?: WebAuthnRegisterStartOptions): Promise<WebAuthnRegisterResponse>;
    authenticate(options: WebAuthnAuthenticateStartOptions): Promise<WebAuthnAuthenticateResponse>;
}
type DynamicConfig$1 = Promise<{
    pkceRequiredForPasswordResets: boolean;
}>;
declare class HeadlessPasswordClient implements IHeadlessPasswordClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _config;
    private executeRecaptcha;
    constructor(_networkClient: INetworkClient, _subscriptionService: ISubscriptionService, _pkceManager: IPKCEManager, _config?: DynamicConfig$1, executeRecaptcha?: () => Promise<string | undefined>);
    private getCodeChallenge;
    create(options: PasswordCreateOptions): Promise<PasswordCreateResponse>;
    authenticate(options: PasswordAuthenticateOptions): Promise<PasswordAuthenticateResponse>;
    resetByEmailStart(options: PasswordResetByEmailStartOptions): Promise<PasswordResetByEmailStartResponse>;
    resetByEmail(options: PasswordResetByEmailOptions): Promise<PasswordResetByEmailResponse>;
    resetByExistingPassword(options: PasswordResetByExistingPasswordOptions): Promise<PasswordResetByExistingPasswordResponse>;
    resetBySession(options: PasswordResetBySessionOptions): Promise<PasswordResetBySessionResponse>;
    strengthCheck(options: PasswordStrengthCheckOptions): Promise<PasswordStrengthCheckResponse>;
}
export { TEST_API_URL, LIVE_API_URL, CLIENTSIDE_SERVICES_IFRAME_URL, STYTCH_WEB_BACKEND_URL, STYTCH_SESSION_COOKIE, STYTCH_SESSION_JWT_COOKIE, POWERED_BY_STYTCH_IMG_URL, GOOGLE_ONE_TAP_HOST, GOOGLE_ONE_TAP_SCRIPT_URL, STYTCH_CSRF_TOKEN_NAME, DEFAULT_SESSION_DURATION_MINUTES, DEFAULT_OTP_EXPIRATION_MINUTES, ErrorMarshaller, IframeHostClient, IframeEmbeddedClient, RPCManifest, OneTapStartRequest, OneTapStartResponse, OneTapSubmitRequest, OneTapSubmitResponse, AnalyticsEvent, DeepPartial, BootstrapData, EnvironmentOptions, SessionPersistenceOptions, StytchClientOptions, loadESModule, checkPublicToken, checkNotSSR, logger, isTestPublicToken, createDeepEqual, normalizePromiseLike, createEventId, createAppSessionId, createPersistentId, validate, isPhoneMethod, isEmailMethod, removeResponseCommon, WithUser, omitUser, IStorageClient, SDKRequestInfo, SDKTelemetry, INetworkClient, baseFetchSDK, ProofkeyPair, IPKCEManager, ISessionManager, SessionManager, SubscriptionDataLayer, ISubscriptionService, SubscriptionService, DEFAULT_MAX_BATCH_SIZE, DEFAULT_INTERVAL_DURATION_MS, EventLogger, HeadlessUserClient, HeadlessSessionClient, HeadlessMagicLinksClient, HeadlessOTPClient, HeadlessOAuthClient, HeadlessCryptoWalletClient, HeadlessTOTPClient, HeadlessWebAuthnClient, HeadlessPasswordClient };
