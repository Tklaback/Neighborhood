'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */

exports.Products = void 0;

(function (Products) {
  Products["emailMagicLinks"] = "emailMagicLinks";
  Products["oauth"] = "oauth";
  Products["otp"] = "otp";
  Products["crypto"] = "crypto";
  Products["passwords"] = "passwords";
})(exports.Products || (exports.Products = {}));
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, and `Slack`.
 */


exports.OAuthProviders = void 0;

(function (OAuthProviders) {
  OAuthProviders["Google"] = "google";
  OAuthProviders["Microsoft"] = "microsoft";
  OAuthProviders["Apple"] = "apple";
  OAuthProviders["Github"] = "github";
  OAuthProviders["GitLab"] = "gitlab";
  OAuthProviders["Facebook"] = "facebook";
  OAuthProviders["Discord"] = "discord";
  OAuthProviders["Slack"] = "slack";
  OAuthProviders["Amazon"] = "amazon";
  OAuthProviders["Bitbucket"] = "bitbucket";
  OAuthProviders["LinkedIn"] = "linkedin";
  OAuthProviders["Coinbase"] = "coinbase";
  OAuthProviders["Twitch"] = "twitch";
})(exports.OAuthProviders || (exports.OAuthProviders = {}));
/**
 * The Crypto Wallets we support in our crypto product.
 * Currently we support all ethereum and solana wallets.
 * We additionally detect and show popular wallets as distinct options.
 * The list of poular wallets include `Binance`, `Coinbase`, `Metamask`, `Phantom`, and `Vessel`
 */


exports.Wallets = void 0;

(function (Wallets) {
  Wallets["Vessel"] = "Vessel";
  Wallets["Phantom"] = "Phantom";
  Wallets["Metamask"] = "Metamask";
  Wallets["Coinbase"] = "Coinbase";
  Wallets["Binance"] = "Binance";
  Wallets["GenericEthereumWallet"] = "Other Ethereum Wallet";
  Wallets["GenericSolanaWallet"] = "Other Solana Wallet";
})(exports.Wallets || (exports.Wallets = {}));
/**
 * For Google One Tap, we support two different position options:
 * `embedded` will display Google One Tap within the existing JavaScript SDK login form
 * `floating` will display the One Tap prompt in the top right corner.
 */


exports.OneTapPositions = void 0;

(function (OneTapPositions) {
  OneTapPositions["embedded"] = "embedded";
  OneTapPositions["floating"] = "floating";
})(exports.OneTapPositions || (exports.OneTapPositions = {}));
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */


exports.OTPMethods = void 0;

(function (OTPMethods) {
  OTPMethods["SMS"] = "sms";
  OTPMethods["WhatsApp"] = "whatsapp";
  OTPMethods["Email"] = "email";
})(exports.OTPMethods || (exports.OTPMethods = {}));

exports.StytchEventType = void 0;

(function (StytchEventType) {
  StytchEventType["MagicLinkLoginOrCreateEvent"] = "MAGIC_LINK_LOGIN_OR_CREATE";
  StytchEventType["OTPsLoginOrCreateEvent"] = "OTP_LOGIN_OR_CREATE";
  StytchEventType["OTPsAuthenticate"] = "OTP_AUTHENTICATE";
  StytchEventType["CryptoWalletAuthenticateStart"] = "CRYPTO_WALLET_AUTHENTICATE_START";
  StytchEventType["CryptoWalletAuthenticate"] = "CRYPTO_WALLET_AUTHENTICATE";
  StytchEventType["PasswordCreate"] = "PASSWORD_CREATE";
  StytchEventType["PasswordAuthenticate"] = "PASSWORD_AUTHENTICATE";
  StytchEventType["PasswordResetByEmailStart"] = "PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["PasswordResetByEmail"] = "PASSWORD_RESET_BY_EMAIL"; // More Events will go here ...
})(exports.StytchEventType || (exports.StytchEventType = {}));
/**
 * An Error class thrown when the SDK is unable to reach the Stytch servers,
 * or when the Stytch servers return a value the SDK cannot understand.
 * Usually - it means that you're offline!
 */


var SDKAPIUnreachableError = /*#__PURE__*/function (_Error) {
  _inherits(SDKAPIUnreachableError, _Error);

  var _super = _createSuper(SDKAPIUnreachableError);

  function SDKAPIUnreachableError(message, details) {
    var _this;

    _classCallCheck(this, SDKAPIUnreachableError);

    _this = _super.call(this, message + '\n' + details);
    _this.message = message + '\n' + details;
    _this.name = 'SDKAPIUnreachableError';
    _this.details = details;
    Object.setPrototypeOf(_assertThisInitialized(_this), SDKAPIUnreachableError.prototype);
    return _this;
  }

  return _createClass(SDKAPIUnreachableError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input fails client-side validation -
 * for example if a field that was expected to be a number is instead a string.
 */


var StytchSDKUsageError = /*#__PURE__*/function (_Error2) {
  _inherits(StytchSDKUsageError, _Error2);

  var _super2 = _createSuper(StytchSDKUsageError);

  function StytchSDKUsageError(methodName, message) {
    var _this2;

    _classCallCheck(this, StytchSDKUsageError);

    _this2 = _super2.call(this);
    _this2.name = 'StytchSDKUsageError';
    _this2.message = "Invalid call to ".concat(methodName, "\n") + message;
    return _this2;
  }

  return _createClass(StytchSDKUsageError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input does not adhere to the Stytch API schema -
 * for example if a field that was expected to be a number is instead a string.
 */


var StytchSDKSchemaError = /*#__PURE__*/function (_Error3) {
  _inherits(StytchSDKSchemaError, _Error3);

  var _super3 = _createSuper(StytchSDKSchemaError);

  function StytchSDKSchemaError(schemaError) {
    var _this3;

    _classCallCheck(this, StytchSDKSchemaError);

    var _a;

    _this3 = _super3.call(this);
    _this3.name = 'StytchSDKSchemaError';
    var messages = (_a = schemaError.body) === null || _a === void 0 ? void 0 : _a.map(function (err) {
      return "".concat(err.dataPath, ": ").concat(err.message);
    }).join('\n');
    _this3.message = "[400] Request does not match expected schema\n".concat(messages);
    return _this3;
  }

  return _createClass(StytchSDKSchemaError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class wrapping a well-formed JSON error from the Stytch API.
 * The Stytch error should match one listed at {@link https://stytch.com/docs/api/errors}
 */


var StytchSDKAPIError = /*#__PURE__*/function (_Error4) {
  _inherits(StytchSDKAPIError, _Error4);

  var _super4 = _createSuper(StytchSDKAPIError);

  function StytchSDKAPIError(details) {
    var _this4;

    _classCallCheck(this, StytchSDKAPIError);

    _this4 = _super4.call(this);
    _this4.name = 'StytchSDKAPIError';
    var status_code = details.status_code,
        error_type = details.error_type,
        error_message = details.error_message,
        error_url = details.error_url,
        request_id = details.request_id;
    _this4.error_type = error_type;
    _this4.error_message = error_message;
    _this4.error_url = error_url;
    _this4.request_id = request_id;
    _this4.status_code = status_code;
    _this4.message = "[".concat(status_code, "] ").concat(error_type, "\n") + "".concat(error_message, "\n") + "See ".concat(error_url, " for more information.\n") + ( // Web-Backend doesn't have request IDs yet, so if a request fails there it won't have one.
    // We should figure out how returning tracing info should work
    request_id ? "request_id: ".concat(request_id, "\n") : '');
    return _this4;
  }

  return _createClass(StytchSDKAPIError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.SDKAPIUnreachableError = SDKAPIUnreachableError;
exports.StytchSDKAPIError = StytchSDKAPIError;
exports.StytchSDKSchemaError = StytchSDKSchemaError;
exports.StytchSDKUsageError = StytchSDKUsageError;
