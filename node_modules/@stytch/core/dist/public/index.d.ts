// Factors
interface EmailFactor {
    delivery_method: "email" | "embedded";
    type: string;
    last_authenticated_at: string;
    email_factor: {
        email_id: string;
        email_address: string;
    };
}
interface PhoneNumberFactor {
    delivery_method: "sms" | "whatsapp";
    type: string;
    last_authenticated_at: string;
    phone_number_factor: {
        phone_id: string;
        phone_number: string;
    };
}
interface GoogleOAuthFactor {
    delivery_method: "oauth_google";
    type: string;
    last_authenticated_at: string;
    google_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface MicrosoftOAuthFactor {
    delivery_method: "oauth_microsoft";
    type: string;
    last_authenticated_at: string;
    microsoft_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface AppleOAuthFactor {
    delivery_method: "oauth_apple";
    type: string;
    last_authenticated_at: string;
    apple_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface GithubOAuthFactor {
    delivery_method: "oauth_github";
    type: string;
    last_authenticated_at: string;
    github_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface GitLabOAuthFactor {
    delivery_method: "oauth_gitlab";
    type: string;
    last_authenticated_at: string;
    gitlab_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface FacebookOAuthFactor {
    delivery_method: "oauth_facebook";
    type: string;
    last_authenticated_at: string;
    facebook_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface DiscordOAuthFactor {
    delivery_method: "oauth_discord";
    type: string;
    last_authenticated_at: string;
    discord_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface SlackOAuthFactor {
    delivery_method: "oauth_slack";
    type: string;
    last_authenticated_at: string;
    slack_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface AmazonOAuthFactor {
    delivery_method: "oauth_amazon";
    type: string;
    last_authenticated_at: string;
    amazon_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface BitbucketOAuthFactor {
    delivery_method: "oauth_bitbucket";
    type: string;
    last_authenticated_at: string;
    bitbucket_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface LinkedInOAuthFactor {
    delivery_method: "oauth_linkedin";
    type: string;
    last_authenticated_at: string;
    linkedin_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface CoinbaseOAuthFactor {
    delivery_method: "oauth_coinbase";
    type: string;
    last_authenticated_at: string;
    coinbase_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface TwitchOAuthFactor {
    delivery_method: "oauth_twitch";
    type: string;
    last_authenticated_at: string;
    twitch_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface WebAuthnFactor {
    delivery_method: "webauthn_registration";
    type: string;
    last_authenticated_at: string;
    webauthn_factor: {
        webauthn_registration_id: string;
        domain: string;
        user_agent: string;
    };
}
interface AuthenticatorAppFactor {
    delivery_method: "authenticator_app";
    type: string;
    last_authenticated_at: string;
    authenticator_app_factor: {
        totp_id: string;
    };
}
interface RecoveryCodeFactor {
    delivery_method: "recovery_code";
    type: string;
    last_authenticated_at: string;
    recovery_code_factor: {
        totp_recovery_code_id: string;
    };
}
interface CryptoWalletFactor {
    delivery_method: "crypto_wallet";
    type: string;
    last_authenticated_at: string;
    crypto_wallet_factor: {
        crypto_wallet_id: string;
        crypto_wallet_address: string;
        crypto_wallet_type: string;
    };
}
interface PasswordFactor {
    delivery_method: "knowledge";
    type: string;
    last_authenticated_at: string;
}
type AuthenticationFactor = EmailFactor | PhoneNumberFactor | GoogleOAuthFactor | MicrosoftOAuthFactor | AppleOAuthFactor | GithubOAuthFactor | GitLabOAuthFactor | FacebookOAuthFactor | DiscordOAuthFactor | SlackOAuthFactor | AmazonOAuthFactor | BitbucketOAuthFactor | LinkedInOAuthFactor | CoinbaseOAuthFactor | TwitchOAuthFactor | WebAuthnFactor | AuthenticatorAppFactor | RecoveryCodeFactor | CryptoWalletFactor | PasswordFactor;
type Session = {
    attributes: {
        ip_address: string;
        user_agent: string;
    };
    /**
     * All the authentication factors that have been associated with the current session.
     * @example
     * const userIsMFAd = session.authentication_factors.length > 2;
     */
    authentication_factors: Array<AuthenticationFactor>;
    /**
     * The timestamp of the session's expiration.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    expires_at: string;
    /**
     * The timestamp of the last time the session was accessed.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    last_accessed_at: string;
    /**
     * Globally unique UUID that identifies a specific session in the Stytch API.
     */
    session_id: string;
    /**
     * The timestamp of the session's creation.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    started_at: string;
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * A map of the custom claims associated with the session.
     * Custom claims can only be set from the server, they cannot be set using the clientside SDKs.
     * After claims have been added to a session, call {@link IHeadlessSessionClient#authenticate stytch.sessions.authenticate} to refresh the session state clientside.
     * See our {@link https://stytch.com/docs/sessions#using-sessions_custom-claims guide} for more information.
     * If no claims are set, this field will be null.
     */
    custom_claims: null | Record<string, unknown>;
};
type SessionAuthenticateOptions = Partial<SessionDurationOptions>;
type SessionAuthenticateResponse = AuthenticateResponse;
type SessionRevokeResponse = ResponseCommon;
type SessionOnChangeCallback = (session: Session | null) => void;
type SessionTokens = {
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/api/session-auth SessionsAuthenticate}
     * endpoint before a user takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * You can retrieve your project's public keyset via our {@link https://stytch.com/docs/api/jwks-get GetJWKS} endpoint
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string;
};
interface IHeadlessSessionClient {
    /**
     * If logged in, `getSync` returns the in-memory session object. Otherwise, it returns `null`.
     * @example
     * const sess = stytch.session.getSync();
     * const hasWebAuthn = sess.authentication_factors.find(
     *   factor => factor.delivery_method === 'webauthn_registration'
     * );
     * @returns The user's active {@link Session} object or `null`
     */
    getSync(): Session | null;
    /**
     * If logged in, `getTokens` returns the session tokens currently issued to the client.
     * Stytch issues two types of tokens - opaque bearer tokens and JWTs.
     * See Stytch's {@link https://stytch.com/docs/sessions#using-sessions session management guide} for an explanation of the difference between the two.
     * On each request authenticate the user's session on the backend using one of Stytch's client libraries.
     *
     * @example
     * const {session_jwt} = stytch.session.getTokens();
     * fetch('https://api.example.com, {
     *   headers: new Headers({
     *    'Authorization': 'Bearer ' + session_jwt,
     *    credentials: 'include',
     *   }),
     * })
     *
     */
    getTokens(): SessionTokens | null;
    /**
     * Use `onChange` to register a listener for session change events.
     * If using `@stytch/react` or `@stytch/nextjs` - you may prefer the `useStytchSession` hook.
     * @example
     * stytch.session.onChange((sess) => {
     *   if(!sess) {
     *     // The user has been logged out!
     *     window.location.href = 'https://example.com/login'
     *   }
     * })
     * @param callback - {@link SessionOnChangeCallback}
     */
    onChange(callback: SessionOnChangeCallback): UnsubscribeFunction;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/session-auth authenticate } Session endpoint and validates that the session issued to the user is still valid.
     * You can call this method to programmatically extend the lifetime of the user's existing session
     * If you're trying to determine if the user is logged in, call {@link IHeadlessSessionClient.getSync} instead.
     * @example
     * stytch.session.authenticate({
     *   // Extend the session for another 60 minutes
     *   session_duration_minutes: 60
     * })
     * @param options - {@link SessionAuthenticateOptions}
     * @returns A {@link SessionAuthenticateResponse}
     */
    authenticate(options?: SessionAuthenticateOptions): Promise<SessionAuthenticateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/session-revoke revoke} Session endpoint and revokes the user's current session.
     * This method should be used to log out a user.
     * @example
     * stytch.sessions.revoke()
     *   .then(() => window.location.href = 'https://example.com/login');
     * @returns A {@link SessionRevokeResponse}
     */
    revoke(): Promise<SessionRevokeResponse>;
}
type ResponseCommon = {
    /**
     * Globally unique UUID that is returned with every API call.
     * This value is important to log for debugging purposes;
     * Stytch may ask for this value to help identify a specific API call when helping you debug an issue.
     */
    request_id: string;
    /**
     * The HTTP status code of the response.
     * Stytch follows standard HTTP response status code patterns, e.g. 2XX values equate to success,
     * 3XX values are redirects, 4XX are client errors, and 5XX are server errors.
     */
    status_code: number;
};
type User = {
    /**
     * The timestamp of the user's creation.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    created_at: string;
    /**
     * The `crypto_wallets` array contains a list of all crypto wallets that a user has linked via Stytch.
     */
    crypto_wallets: Array<{
        /**
         * Globally unique UUID that identifies a specific crypto wallet in the Stytch API.
         * The `crypto_wallet_id` is used when you need to operate on a specific user's crypto wallet, e.g. to remove the crypto wallet from the Stytch user.
         */
        crypto_wallet_id: string;
        /**
         * The `crypto_wallet_address` is the actual blockchain address of this user's crypto wallet.
         */
        crypto_wallet_address: string;
        /**
         * The `crypto_wallet_type` is the blockchain that the user's crypto wallet operates on, e.g. Ethereum, Solana, etc.
         */
        crypto_wallet_type: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    /**
     * The `emails` array contains an array of `email` objects for the user.
     */
    emails: Array<{
        /**
         * The email address.
         */
        email: string;
        /**
         * Globally unique UUID that identifies a specific email address in the Stytch API.
         * The `email_id` is used when you need to operate on a specific user's email address,
         * e.g. to delete the email address from the Stytch user.
         */
        email_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    name: {
        first_name: string;
        last_name: string;
        middle_name: string;
    };
    /**
     * The `phone_numbers` array contains an array of phone number objects for the user.
     */
    phone_numbers: Array<{
        /**
         * A phone number.
         */
        phone_number: string;
        /**
         * Globally unique UUID that identifies a specific phone number in the Stytch API.
         * The `phone_id` is used when you need to operate on a specific user's phone number,
         * e.g. to delete the phone number from the Stytch user.
         */
        phone_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    /**
     * The `providers` array contains an array of provider objects for the user, i.e. which OAuth providers the user has used to link their account.
     */
    providers: Array<{
        /**
         * The `provider_subject` field is the unique identifier used to identify the user within a given OAuth provider.
         * Also commonly called the "sub" or "Subject field" in OAuth protocols.
         */
        provider_subject: string;
        /**
         * The `type` field denotes the OAuth identity provider that the user has authenticated with, e.g. Google, Facebook, GitHub etc.
         */
        provider_type: string;
        /**
         * If available, the `profile_picture_url` is a url of the user's profile picture set in OAuth identity the provider that the user has authenticated with, e.g. Facebook profile picture.
         */
        profile_picture_url: string;
        /**
         * If available, the `locale` is the user's locale set in the OAuth identity provider that the user has authenticated with.
         */
        locale: string;
    }>;
    /**
     * The `password` object is returned for users with a password.
     */
    password: null | {
        /**
         * Globally unique UUID that identifies a specific password in the Stytch API.
         */
        password_id: string;
        /**
         * The `requires_reset` field indicates whether the user will need to reset their password to use it in the future.
         * See {@link https://stytch.com/docs/api/password-authenticate the API docs} for explanations of scenarios where
         * this might be required.
         */
        requires_reset: boolean;
    };
    /**
     * The `status` value denotes whether or not a user has successfully logged in at least once with any available login method.
     * Possible values are `active` and `pending`.
     */
    status: "active" | "pending";
    /**
     * The `totps` array contains a list of all TOTP instances for a given user in the Stytch API.
     */
    totps: Array<{
        /**
         * Globally unique UUID that identifies a specific TOTP instance in the Stytch API.
         * The `totp_id` is used when you need to operate on a specific user's TOTP instance, e.g. to delete the TOTP instance from the Stytch user.
         */
        totp_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }>;
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
    /**
     * The `webauthn_registrations` array contains a list of all WebAuthn registrations for a given user in the Stytch API.
     */
    webauthn_registrations: Array<{
        /**
         * The `domain` on which a WebAuthn registration was started.
         * This will be the domain of your app.
         */
        domain: string;
        /**
         * The `user_agent` of the user's browser or device.
         */
        user_agent: string;
        /**
         * The `authenticator_type` string displays the requested authenticator type of the WebAuthn device.
         * The two valid types are "platform" and "cross-platform".
         * If no value is present, the WebAuthn device was created without an authenticator type preference.
         */
        authenticator_type: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
        /**
         * Globally unique UUID that identifies a specific WebAuthn registration in the Stytch API.
         * The `webauthn_registration_id` is used when you need to operate on a specific user's WebAuthn registration,
         * e.g. to delete the WebAuthn instance from the Stytch user.
         */
        webauthn_registration_id: string;
    }>;
};
type AuthenticateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/api/session-auth SessionsAuthenticate}
     * endpoint before a user takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * You can retrieve your project's public keyset via our {@link https://stytch.com/docs/api/jwks-get GetJWKS} endpoint
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string;
    /**
     * The Session object created.
     * See {@link Session} for details.
     */
    session: Session;
    /**
     * The user object affected by this API call.
     * See the {@link https://stytch.com/docs/api/get-user Get user} endpiont for complete response field detail.
     */
    user: User;
};
type DeleteResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
};
type UpdateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
};
type SessionDurationOptions = {
    /**
     * Set the session lifetime to be this many minutes from now.
     * This will return both an opaque `session_token` and `session_jwt` for this session, which will automatically be stored in the browser cookies.
     * The `session_jwt` will have a fixed lifetime of five minutes regardless of the underlying session duration, and will be automatically refreshed by the SDK in the background over time.
     * This value must be a minimum of 5 and may not exceed the maximum session duration minutes value set in the
     * {@link https://stytch.com/dashboard/sdk-configuration SDK Configuration } page of the Stytch dashboard.
     */
    session_duration_minutes: number;
};
type UnsubscribeFunction = () => void;
type OAuthGetURLOptions = {
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a user that already exists.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Login URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    login_redirect_url?: string;
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a user that does not yet exist.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Sign Up URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    signup_redirect_url?: string;
    /**
     * An optional list of custom scopes that you'd like to request from the user in addition to the ones Stytch requests by default.
     * @example Google Custom Scopes
     * ['https://www.googleapis.com/auth/gmail.compose', 'https://www.googleapis.com/auth/firebase']
     *
     * @example Facebook Custom Scopes
     * ['public_profile', 'instagram_shopping_tag_products']
     */
    custom_scopes?: string[];
};
type OAuthAuthenticateOptions = SessionDurationOptions;
type OAuthAuthenticateResponse = AuthenticateResponse & {
    /**
     * The `provider_subject` field is the unique identifier used to identify the user within a given OAuth provider.
     * Also commonly called the "sub" or "Subject field" in OAuth protocols.
     */
    provider_subject: string;
    /**
     * The `type` field denotes the OAuth identity provider that the user has authenticated with, e.g. Google, Facebook, GitHub etc.
     */
    provider_type: string;
    /**
     * If available, the `profile_picture_url` is a url of the user's profile picture set in OAuth identity the provider that the user has authenticated with, e.g. Facebook profile picture.
     */
    profile_picture_url: string;
    /**
     * If available, the `locale` is the user's locale set in the OAuth identity provider that the user has authenticated with.
     */
    locale: string;
    /**
     * The `provider_values` object lists relevant identifiers, values, and scopes for a given OAuth provider.
     * For example this object will include a provider's `access_token` that you can use to access the provider's API for a given user.
     * Note that these values will vary based on the OAuth provider in question, e.g. `id_token` may not be returned by all providers.
     */
    provider_values: {
        /**
         * The `access_token` that you may use to access the user's data in the provider's API.
         */
        access_token: string;
        /**
         * The `id_token` returned by the OAuth provider.
         * This value is similar to an access token but usually may only be used to hit a provider's OIDC endpoint, i.e. login or fetch a session, but not directly interact with the provider's API.
         * See {@link https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens here} for more details on how Microsoft treats `id_token`s.
         */
        id_token: string;
        /**
         * The `refresh_token` that you may use to refresh a user's session within the provider's API.
         */
        refresh_token: string;
        /**
         * The OAuth scopes included for a given provider.
         * See each provider's section above to see which scopes are included by default and how to add custom scopes.
         */
        scopes: string[];
    };
};
/**
 * Methods for interacting with an individual OAuth provider.
 */
interface IOAuthProvider {
    /**
     * Start an OAuth flow by redirecting the browser to one of Stytch's {@link https://stytch.com/docs/api/oauth-google-start oauth start} endpoints.
     * If enabled, this method will also generate a PKCE code_verifier and store it in localstorage on the device (See the {@link https://stytch.com/docs/oauth#guides_pkce PKCE OAuth guide} for details).
     * If your application is configured to use a custom subdomain with Stytch, it will be used automatically.
     * @example
     * const loginWithGoogle = useCallback(()=> {
     *   stytch.oauth.google.start({
     *     login_redirect_url: 'https://example.com/oauth/callback',
     *     signup_redirect_url: 'https://example.com/oauth/callback',
     *     custom_scopes: ['https://www.googleapis.com/auth/gmail.compose']
     *   })
     * }, [stytch]);
     * return (
     *   <Button onClick={loginWithGoogle}> Log in! </Button>
     * );
     *
     * @param options - An {@link OAuthGetURLOptions} object
     *
     * @returns void - the browser is redirected during this function call. You should not attempt to run any code after calling this function.
     *
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    start(options?: OAuthGetURLOptions): Promise<void>;
}
interface IHeadlessOAuthClient {
    google: IOAuthProvider;
    microsoft: IOAuthProvider;
    apple: IOAuthProvider;
    github: IOAuthProvider;
    gitlab: IOAuthProvider;
    facebook: IOAuthProvider;
    discord: IOAuthProvider;
    slack: IOAuthProvider;
    amazon: IOAuthProvider;
    bitbucket: IOAuthProvider;
    linkedin: IOAuthProvider;
    coinbase: IOAuthProvider;
    twitch: IOAuthProvider;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/oauth-authenticate oauth authenticate} endpointwhich validates the OAuth token passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * const token = new URLSearchParams(window.location.search).get('token');
     * stytch.oauth.authenticate(token, {
     *   session_duration_minutes: 60
     * }).then(...)
     *
     * @param token - The token to authenticate
     * @param options - {@link OAuthAuthenticateOptions}
     *
     * @returns A {@link OAuthAuthenticateResponse} indicating the token has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(token: string, options: OAuthAuthenticateOptions): Promise<OAuthAuthenticateResponse>;
}
type UserOnChangeCallback = (user: User | null) => void;
type UserUpdateOptions = {
    /**
     * The name of the user. If at least one name field is passed, all name fields will be updated.
     */
    name?: {
        /**
         * The first name of the user. Replaces an existing first name, if it exists.
         */
        first_name?: string;
        /**
         * The middle name(s) of the user. Replaces an existing middle name, if it exists.
         */
        middle_name?: string;
        /**
         * The last name of the user. Replaces an existing last name, if it exists.
         */
        last_name?: string;
    };
};
type UserUpdateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * The updated emails for the user.
     */
    emails: User["emails"];
    /**
     * The updated phone numbers for the user.
     */
    phone_numbers: User["phone_numbers"];
    /**
     * The updated crypto wallets for the user.
     */
    crypto_wallets: User["crypto_wallets"];
};
interface IHeadlessUserClient {
    /**
     * The asynchronous method for getting a user. This wraps the {@link https://stytch.com/docs/api/get-user get} user endpoint.
     * It fetches the user's data and refreshes the cached object if changes are detected.
     * The Stytch SDK will invoke this method automatically in the background, so you probably won't need to call this method directly.
     *
     * @returns A {@link User} object, or null if no user exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    get(): Promise<User | null>;
    /**
     * Wraps Stytch's {@link update https://stytch.com/docs/api/update-user} user endpoint. Use this method to change the user's name.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * const updateName = useCallback(() => {
     *  stytchClient.user.update({
     *    name: {
     *      first_name: 'Jane',
     *      last_name: 'Doe',
     *    },
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link UserUpdateOptions}
     *
     * @returns A {@link UserUpdateResponse} indicating the user has been updated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    update(options: UserUpdateOptions): Promise<UserUpdateResponse>;
    /**
     * The synchronous method for getting a user. This is the recommended approach. You can listen to changes with the {@link onChange onChange} method.
     * If logged in, this returns the cached user object, otherwise it returns null. This method does not refresh the user's data.
     * The `stytch-react` library provides the `useStytchUser` hook that implements these methods for you to easily access the user and listen for changes.
     *
     * @returns A {@link User} object, or null if no user exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    getSync(): User | null;
    /**
     * Allows listening to changes in the user object when using {@link getSync getSync()}.
     *
     * @param callback - Gets called whenever the user object changes. See {@link UserOnChangeCallback}.
     *
     * @returns An {@link UnsubscribeFunction} for you to call when you no longer want to listen for changes in the user object.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    onChange(callback: UserOnChangeCallback): UnsubscribeFunction;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-email delete user email} endpoint.
     * This methods cannot be used to remove all factors from a user. A user must have at least one email, phone number, or OAuth provider associated with their account at all times, otherwise they will not be able to log in again.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param emailId - ID of the email to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user email has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteEmail(emailId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-phone-number delete phone number} endpoint.
     * This methods cannot be used to remove all factors from a user. A user must have at least one email, phone number, or OAuth provider associated with their account at all times, otherwise they will not be able to log in again.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param phoneId - ID of the phone number to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user phone number has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deletePhoneNumber(phoneId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-totp delete TOTP} endpoint.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param totpId - ID of the TOTP registration to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user TOTP registration has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteTOTP(totpId: string): Promise<DeleteResponse>;
}
type MagicLinksBaseOptions = {
    /**
     * The url the user clicks from the sign-up email magic link.
     * This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and sign-up the user.
     * If this value is not passed, the default sign-up redirect URL that you set in your Dashboard is used.
     * If you have not set a default sign-up redirect URL, an error is returned.
     */
    signup_magic_link_url?: string;
    /**
     * Set the expiration for the sign-up email magic link, in minutes.
     * By default, it expires in 1 week.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    signup_expiration_minutes?: number;
    /**
     * The url the user clicks from the login email magic link.
     * This should be a url that your app receives and parses and subsequently send an API request to authenticate the magic link and log in the user.
     * If this value is not passed, the default login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_magic_link_url?: string;
    /**
     * Set the expiration for the login email magic link, in minutes.
     * By default, it expires in 1 hour.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    login_expiration_minutes?: number;
};
type MagicLinksLoginOrCreateOptions = MagicLinksBaseOptions;
type MagicLinksSendOptions = MagicLinksBaseOptions;
type MagicLinksLoginOrCreateResponse = ResponseCommon;
type MagicLinksSendResponse = ResponseCommon;
type MagicLinksAuthenticateOptions = SessionDurationOptions;
type MagicLinksAuthenticateResponse = AuthenticateResponse & {
    /**
     * The ID of the method used to send a magic link.
     */
    method_id: string;
};
interface IHeadlessMagicLinksClient {
    email: {
        /**
         * The loginOrCreate method wraps the {@link https://stytch.com/docs/api/log-in-or-create-user-by-email login_or_create} Email magic link API endpoint.
         *
         * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_send Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.loginOrCreate('sandbox@stytch.com', {
         *   login_magic_link_url: 'https://example.com/authenticate',
         *   login_expiration_minutes: 60,
         *   signup_magic_link_url: 'https://example.com/authenticate',
         *   signup_expiration_minutes: 60,
         * });
         *
         * @param email - The email of the user to send the invite magic link to.
         * @param options - {@link MagicLinksLoginOrCreateOptions}
         *
         * @returns A {@link MagicLinksLoginOrCreateResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        loginOrCreate(email: string, options?: MagicLinksLoginOrCreateOptions): Promise<MagicLinksLoginOrCreateResponse>;
        /**
         * The send method wraps the {@link https://stytch.com/docs/api/send-by-email send} Email magic link API endpoint.
         *
         * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_send Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.send('sandbox@stytch.com', {
         *   login_magic_link_url: 'https://example.com/authenticate',
         *   login_expiration_minutes: 60,
         *   signup_magic_link_url: 'https://example.com/authenticate',
         *   signup_expiration_minutes: 60,
         * });
         *
         * @param email - The email of the user to send the invite magic link to.
         * @param options - {@link MagicLinksSendOptions}
         *
         * @returns A {@link MagicLinksSendResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        send(email: string, options?: MagicLinksSendOptions): Promise<MagicLinksSendResponse>;
    };
    /**
     * The Authenticate method wraps the {@link https://stytch.com/docs/api/authenticate-magic-link authenticate}
     * Magic link API endpoint which validates the magic link token passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_authenticate Stytch Docs} for a complete reference.
     *
     * @example
     * const currentLocation = new URL(window.location.href);
     * const token = currentLocation.searchParams.get('token');
     * stytch.magicLinks.authenticate(token, {
     *   session_duration_minutes: 60,
     * });
     *
     * @param token - The magic link token from the token query parameter in the URL.
     * @param options - {@link MagicLinksLoginOrCreateOptions}
     *
     * @returns A {@link MagicLinksAuthenticateResponse} indicating that magic link has been authenticated and the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(token: string, options: MagicLinksAuthenticateOptions): Promise<MagicLinksAuthenticateResponse>;
}
type OTPCodeOptions = {
    /**
     * Set the expiration for the one-time passcode, in minutes. The minimum expiration is 1 minute and the maximum is 10 minutes. The default expiration is 2 minutes.
     */
    expiration_minutes: number;
};
type OTPAuthenticateOptions = {
    /**
     * Set the session lifetime to be this many minutes from now.
     * This value must be a minimum of 5 and may not exceed the `maximum session duration minutes` value set in the {@link https://stytch.com/dashboard/sdk-configuration SDK Configuration} page of the Stytch dashboard.
     * A successful authentication will continue to extend the session this many minutes.
     */
    session_duration_minutes: number;
};
type OTPsBaseResponse = ResponseCommon & {
    /**
     * The ID of the method used to send a one-time passcode.
     */
    method_id: string;
};
type OTPsLoginOrCreateResponse = OTPsBaseResponse;
type OTPsSendResponse = OTPsBaseResponse;
type OTPsAuthenticateResponse = AuthenticateResponse & {
    /**
     * The ID of the method used to send a one-time passcode.
     */
    method_id: string;
};
interface IHeadlessOTPsClient {
    sms: {
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-sms login_or_create} via SMS API endpoint. Call this method to send an SMS passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.sms.loginOrCreate('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(phone_number: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/send-otp-by-sms send} via SMS API endpoint. Call this method to send an SMS passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.sms.send('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(phone_number: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    whatsapp: {
        /**
         *  Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-whatsapp login_or_create} via WhatsApp API endpoint. Call this method to send a WhatsApp passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.whatsapp.loginOrCreate('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(phone_number: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/whatsapp-send send} via WhatsApp API endpoint. Call this method to send an WhatsApp passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.whatsapp.send('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(phone_number: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    email: {
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-email login_or_create} via email API endpoint. Call this method to send an email passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.email.loginOrCreate('sandbox@stytch.com', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param email - The email address of the user to send the one-time passcode to. You may use sandbox@stytch.com to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(email: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/send-otp-by-email send} via Email API endpoint. Call this method to send an email passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.email.send('sandbox@stytch.com', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param email - The email address of the user to send the one-time passcode to. You may use sandbox@stytch.com to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(email: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    /**
     * The authenticate method wraps the {@link https://stytch.com/docs/api/authenticate-otp authenticate} one-time passcode API method which validates the code passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link session cookies https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * const [code, setCode] = useState('');
     *
     * const method_id = "phone-number-test-d5a3b680-e8a3-40c0-b815-ab79986666d0"
     * // returned from calling loginOrCreate for OTPs on SMS, WhatsApp or Email
     *
     * const authenticate = useCallback((e) => {
     *  e.preventDefault();
     *  stytchClient.otps.authenticate(code, method_id, {
     *    session_duration_minutes: 60,
     *  });
     * }, [stytchClient, code]);
     *
     * const handleChange = useCallback((e) => {
     *  setCode(e.target.value);
     * }, []);
     * ```
     *
     * @param otp - The code to authenticate.
     * @param method_id - The ID of the method used to send a one-time passcode.
     * @param options - {@link OTPAuthenticateOptions}
     *
     * @returns A {@link OTPsAuthenticateResponse} indicating the one-time passcode method has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(otp: string, method_id: string, options?: OTPAuthenticateOptions): Promise<OTPsAuthenticateResponse>;
}
type CryptoWalletAuthenticateStartOptions = {
    /**
     * The address to authenticate.
     */
    crypto_wallet_address: string;
    /**
     * The type of wallet to authenticate. Currently `ethereum` and `solana` are supported.
     */
    crypto_wallet_type: string;
};
type CryptoWalletAuthenticateStartResponse = ResponseCommon & {
    /**
     * The challenge to be signed by the user's wallet.
     */
    challenge: string;
};
type CryptoWalletAuthenticateOptions = SessionDurationOptions & {
    /**
     * The address to authenticate.
     */
    crypto_wallet_address: string;
    /**
     * The type of wallet to authenticate. Currently `ethereum` and `solana` are supported.
     */
    crypto_wallet_type: string;
    /**
     * The signature from the message.
     */
    signature: string;
};
type CryptoWalletAuthenticateResponse = AuthenticateResponse;
interface IHeadlessCryptoWalletClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/crypto-wallet-authenticate-start authenticate_start} crypto wallet endpoint. Call this method to load the challenge data. Pass this challenge to your user's wallet for signing.
     *
     * @example
     * ```
     * // Request user's address
     * const [crypto_wallet_address] = await ethereum.request({
     *   method: 'eth_requestAccounts',
     * });
     *
     * // Ask Stytch to generate a challenge for the user
     * const { challenge } = await stytch.cryptoWallets.authenticateStart({
     *   crypto_wallet_address: crypto_wallet_address,
     *   crypto_wallet_type: 'ethereum',
     * });
     * ```
     * @param options - {@link CryptoWalletAuthenticateStartOptions}
     *
     * @returns A {@link CryptoWalletAuthenticateStartResponse} containing a challenge to be passed to the user's wallet for signing.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticateStart(options: CryptoWalletAuthenticateStartOptions): Promise<CryptoWalletAuthenticateStartResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/crypto-wallet-authenticate authenticate} crypto wallet endpoint. Call this method after the user signs the challenge to validate the signature.
     * If this method succeeds and the user is not already logged in, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * If the user is already logged in, the crypto wallet will be added to the `user.crypto_wallets[]` array and associated with user's existing session as an `authentication_factor`.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * // Ask the user to sign the challenge
     * const signature = await ethereum.request({
     *   method: 'personal_sign',
     *   params: [challenge, crypto_wallet_address],
     * });
     *
     * // Authenticate the signature
     * stytch.cryptoWallets.authenticate({
     *  crypto_wallet_address: crypto_wallet_address,
     *  crypto_wallet_type: 'ethereum',
     *  signature: signature,
     *  session_duration_minutes: 60,
     * });
     * ```
     *
     * @param options - {@link CryptoWalletAuthenticateOptions}
     *
     * @returns A {@link CryptoWalletAuthenticateResponse} indicating the user has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: CryptoWalletAuthenticateOptions): Promise<CryptoWalletAuthenticateResponse>;
}
type TOTPCreateOptions = {
    /**
     * The expiration for the TOTP instance. If the newly created TOTP is not authenticated within this time frame the TOTP will be unusable. Defaults to 60 (1 hour) with a minimum of 5 and a maximum of 1440.
     */
    expiration_minutes: number;
};
type TOTPCreateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
    /**
     * The TOTP secret key shared between the authenticator app and the server used to generate TOTP codes.
     */
    secret: string;
    /**
     * The QR code image encoded in base64.
     */
    qr_code: string;
    /**
     * The recovery codes used to authenticate the user without an authenticator app.
     */
    recovery_codes: string[];
};
type TOTPAuthenticateOptions = SessionDurationOptions & {
    /**
     * The TOTP code to authenticate. The TOTP code should consist of 6 digits.
     */
    totp_code: string;
};
type TOTPAuthenticateResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
};
type TOTPRecovery = {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
    /**
     * Indicates whether or not the TOTP registration has been verified by the user.
     */
    verified: boolean;
    /**
     * The recovery codes for the TOTP registration.
     */
    recovery_codes: string[];
};
type TOTPRecoveryCodesResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * See {@link TOTPRecovery}.
     */
    totps: TOTPRecovery;
};
type TOTPRecoverOptions = SessionDurationOptions & {
    /**
     * The recovery code to authenticate.
     */
    recovery_code: string;
};
type TOTPRecoverResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
};
interface IHeadlessTOTPClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-create create} endpoint. Call this method to create a new TOTP instance for a user. The user can use the authenticator application of their choice to scan the QR code or enter the secret.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * stytchClient.totps.create({ expiration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPCreateOptions}
     *
     * @returns A {@link TOTPCreateResponse} indicating a new TOTP instance has been created.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    create(options: TOTPCreateOptions): Promise<TOTPCreateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-authenticate authenticate} endpoint. Call this method to authenticate a TOTP code entered by a user.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * stytch.totps.authenticate({ totp_code: '123456', session_duration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPAuthenticateOptions}
     *
     * @returns A {@link TOTPAuthenticateResponse} indicating the TOTP code has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: TOTPAuthenticateOptions): Promise<TOTPAuthenticateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-get-recovery-codes recovery_codes} endpoint. Call this method to retrieve the recovery codes for a TOTP instance tied to a user.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * stytchClient.totps.recoveryCodes();
     * ```
     *
     * @returns A {@link TOTPRecoveryCodesResponse} containing the TOTP recovery codes tied to the user.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    recoveryCodes(): Promise<TOTPRecoveryCodesResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-recover recover} endpoint. Call this method to authenticate a recovery code for a TOTP instance.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * stytch.totps.recover({ recovery_code: 'xxxx-xxxx-xxxx', session_duration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPRecoverOptions}
     *
     * @returns A {@link TOTPRecoverResponse} indicating the TOTP recovery code has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    recover(options: TOTPRecoverOptions): Promise<TOTPRecoverResponse>;
}
type WebAuthnRegisterStartOptions = {
    /**
     * The domain for the WebAuthn registration. Defaults to `window.location.hostname`.
     */
    domain?: string;
    /**
     * The requested authenticator type of the WebAuthn device. The two valid values are `platform` and `cross-platform`. If no value passed, we assume both values are allowed.
     */
    authenticator_type?: "platform" | "cross-platform";
};
type WebAuthnRegisterStartResponse = ResponseCommon & {
    /**
     * The user ID of an active user the WebAuthn registration is for.
     */
    user_id: string;
    /**
     * Options used for WebAuthn registration.
     */
    public_key_credential_creation_options: string;
};
type WebAuthnRegisterResponse = ResponseCommon & {
    /**
     * The user ID of an active user the WebAuthn registration is for.
     */
    user_id: string;
    /**
     * A unique ID that identifies a specific WebAuthn registration.
     */
    webauthn_registration_id: string;
};
type WebAuthnAuthenticateStartOptions = SessionDurationOptions & {
    /**
     * The domain for the WebAuthn registration.
     */
    domain?: string;
};
type WebAuthnAuthenticateStartResponse = ResponseCommon & {
    /**
     * The user ID of an active user the WebAuthn authentication is for.
     */
    userId: string;
    /**
     * Options used for WebAuthn authentication.
     */
    public_key_credential_request_options: string;
};
type WebAuthnAuthenticateResponse = AuthenticateResponse & {
    /**
     * A unique ID that identifies a specific WebAuthn registration.
     */
    webauthn_registration_id: string;
};
interface IHeadlessWebAuthnClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/webauthn-register-start register_start} and {@link https://stytch.com/docs/api/webauthn-register register} WebAuthn endpoints and the {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create navigator.credentials} web API. Call this method to prompt the user to enroll a new WebAuthn factor and save the factor in Stytch.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * const registerWebAuthn = useCallback(() => {
     *  stytchClient.register({
     *    domain: 'subdomain.example.com',
     *    authenticator_type: 'platform'
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link WebAuthnRegisterStartOptions}
     *
     * @returns A {@link WebAuthnRegisterResponse} indicating WebAuthn has been registered.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    register(options?: WebAuthnRegisterStartOptions): Promise<WebAuthnRegisterResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/webauthn-authenticate-start authenticate_start} and {@link https://stytch.com/docs/api/webauthn-authenticate authenticate} WebAuthn endpoints and the navigator.credentials web API.
     * Call this method to prompt the user to authenticate an existing WebAuthn registration.
     * In order to use these methods, the user must have already logged in with a primary method - OAuth, one-time passcodes, or magic links.
     * If this method succeeds, the WebAuthn credential will be added to the user's existing session as an `authentication_factor`, the user will be logged in, granted an active session, and the session cookies will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * const authenticateWebAuthn = useCallback(() => {
     *  stytchClient.webauthn.authenticate({
     *    domain: 'subdomain.example.com',
     *    session_duration_minutes: 60,
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link WebAuthnAuthenticateStartOptions}
     *
     * @returns A {@link WebAuthnAuthenticateResponse} indicating the WebAuthn registration has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: WebAuthnAuthenticateStartOptions): Promise<WebAuthnAuthenticateResponse>;
}
type PasswordCreateOptions = SessionDurationOptions & {
    /**
     * The email of the new user.
     */
    email: string;
    /**
     * The password for the new user.
     */
    password: string;
};
type PasswordCreateResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific email address in the Stytch API.
     * The `email_id` is used when you need to operate on a specific user's email address,
     * e.g. to delete the email address from the Stytch user.
     */
    email_id: string;
};
type PasswordAuthenticateOptions = SessionDurationOptions & {
    /**
     * The email of the user.
     */
    email: string;
    /**
     * The password for the user.
     */
    password: string;
};
type PasswordAuthenticateResponse = AuthenticateResponse;
type PasswordResetByEmailStartOptions = {
    /**
     * The email of the user that requested the password reset.
     */
    email: string;
    /**
     * The url that the user clicks from the password reset email to skip resetting their password and directly login.
     * This should be a url that your app receives, parses, and subsequently sends an API request to the magic link authenticate endpoint to complete the login process without reseting their password.
     * If this value is not passed, the login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_redirect_url?: string;
    /**
     * Set the expiration for the login email magic link, in minutes.
     * By default, it expires in 1 hour.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    login_expiration_minutes?: number;
    /**
     * The url that the user clicks from the password reset email to finish the reset password flow.
     * This should be a url that your app receives and parses before showing your app's reset password page.
     * After the user submits a new password to your app, it should send an API request to complete the password reset process.
     * If this value is not passed, the default reset password redirect URL that you set in your Dashboard is used.
     * If you have not set a default reset password redirect URL, an error is returned.
     */
    reset_password_redirect_url?: string;
    /**
     * Set the expiration for the password reset, in minutes.
     * By default, it expires in 30 minutes.
     * The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     */
    reset_password_expiration_minutes?: number;
};
type PasswordResetByEmailStartResponse = ResponseCommon;
type PasswordResetByEmailOptions = SessionDurationOptions & {
    /**
     * The token to authenticate.
     */
    token: string;
    /**
     * The new password for the user.
     */
    password: string;
};
type PasswordResetByEmailResponse = AuthenticateResponse;
type PasswordResetByExistingPasswordOptions = SessionDurationOptions & {
    /**
     * The user's email.
     */
    email: string;
    /**
     * The user's existing password.
     */
    existing_password: string;
    /**
     * The new password for the user.
     */
    new_password: string;
};
type PasswordResetByExistingPasswordResponse = AuthenticateResponse;
type PasswordResetBySessionOptions = {
    password: string;
};
type PasswordResetBySessionResponse = AuthenticateResponse;
type PasswordStrengthCheckOptions = {
    /**
     * The email associated with the password. Provide this for a more accurate strength check.
     */
    email?: string;
    /**
     * The password to strength check.
     */
    password: string;
};
type PasswordStrengthCheckResponse = ResponseCommon & {
    /**
     * Whether or not the password is considered valid and secure.
     * Read more about password validity {@link https://stytch.com/docs/api/password-strength-check in our docs}.
     */
    valid_password: boolean;
    /**
     * The score of the password as determined by {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    score: number;
    /**
     * Determines if the password has been breached using {@link https://haveibeenpwned.com/ HaveIBeenPwned}.
     */
    breached_password: boolean;
    /**
     * Feedback for how to improve the password's strength using {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    feedback: {
        suggestions: string[];
        warning: string;
    };
};
interface IHeadlessPasswordClient {
    /**
     * The Create method wraps the {@link https://stytch.com/docs/api/password-create Create} Password API endpoint.
     * If a user with this email already exists in the project, this API will return an error.
     * Existing passwordless users who wish to create a password need to go through the reset password flow.
     *
     * This endpoint will return an error if the password provided does not meet our strength requirements,
     * which you can check beforehand with the {@link IHeadlessPasswordClient#strengthCheck password strength} endpoint.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * const {valid_password} = await stytch.passwords.strengthCheck({ email, password });
     * if (valid_password) {
     *   stytch.passwords.create({ email, password, session_duration_minutes: 60 });
     * }
     *
     * @param options - {@link PasswordCreateOptions}
     *
     * @returns A {@link PasswordCreateResponse} indicating the user has been created and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    create(options: PasswordCreateOptions): Promise<PasswordCreateResponse>;
    /**
     * The Authenticate method wraps the {@link https://stytch.com/docs/api/password-authenticate Authenticate} Password API endpoint.
     * This endpoint verifies that the user has a password currently set, and that the entered password is correct.
     *
     * There are cases where this endpoint will return a `reset_password` error even if the password entered is correct.
     * View our {@link https://stytch.com/docs/api/password-authenticate API Docs} for complete details.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * stytch.passwords.authenticate({
     *   email: 'sandbox@stytch.com',
     *   password: aVerySecurePassword,
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link PasswordAuthenticateOptions}
     *
     * @returns A {@link PasswordAuthenticateResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(options: PasswordAuthenticateOptions): Promise<PasswordAuthenticateResponse>;
    /**
     * The resetByEmailStart method wraps the {@link https://stytch.com/docs/api/password-email-reset-start Reset By Email Start} Password API endpoint.
     * This endpoint initiates a password reset for the email address provided.
     * This will trigger an email to be sent to the address, containing a magic link that will allow them to set a new password and authenticate.
     *
     * @example
     * stytch.passwords.resetByEmailStart({
     *   email: 'sandbox@stytch.com',
     *   reset_password_redirect_url: 'https://example.com/login/reset',
     *   reset_password_expiration_minutes: 10,
     *   login_redirect_url: 'https://example.com/login/authenticate',
     * });
     *
     * @param options - {@link PasswordResetByEmailStartOptions}
     *
     * @returns A {@link PasswordResetByEmailStartResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmailStart(options: PasswordResetByEmailStartOptions): Promise<PasswordResetByEmailStartResponse>;
    /**
     * The resetByEmail method wraps the {@link https://stytch.com/docs/api/password-email-reset Reset By Email} Password API endpoint.
     * This endpoint the users password and authenticate them.
     * This endpoint checks that the magic link token is valid, hasn't expired, or already been used.
     * The provided password needs to meet our password strength requirements, which can be checked in advance with the {@link IHeadlessPasswordClient#strengthCheck password strength} endpoint.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * const currentLocation = new URL(window.location.href);
     * const token = currentLocation.searchParams.get('token');
     * stytch.passwords.resetByEmail({
     *   token,
     *   email: 'sandbox@stytch.com',
     *   password: aVerySecurePassword,
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link PasswordResetByEmailOptions}
     *
     * @returns A {@link PasswordResetByEmailResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmail(options: PasswordResetByEmailOptions): Promise<PasswordResetByEmailResponse>;
    /**
     * The strengthCheck method wraps the {@link https://stytch.com/docs/api/password-strength-check Strength Check} Password API endpoint.
     * This endpoint allows you to check whether or not the users provided password is valid,
     * and to provide feedback to the user on how to increase the strength of their password.
     *
     * @example
     * const {valid_password, feedback} = await stytch.passwords.strengthCheck({ email, password });
     * if (!valid_password) {
     *   throw new Error('Password is not strong enough: ' + feedback.warning);
     * }
     *
     * @param options - {@link PasswordStrengthCheckOptions}
     *
     * @returns A {@link PasswordStrengthCheckResponse} containing password strength feedback.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    strengthCheck(options: PasswordStrengthCheckOptions): Promise<PasswordStrengthCheckResponse>;
}
/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */
declare enum Products {
    emailMagicLinks = "emailMagicLinks",
    oauth = "oauth",
    otp = "otp",
    crypto = "crypto",
    passwords = "passwords"
}
/**
 * The options for email magic links. This is required if you've enabled the `emailMagicLinks` product
 * in your configuration.
 */
type EmailMagicLinksOptions = {
    loginRedirectURL: string;
    loginExpirationMinutes?: number;
    signupRedirectURL: string;
    signupExpirationMinutes?: number;
    createUserAsPending?: boolean;
    /**
     * @param domainHint - An optional hint indicating what domain the email will be sent from.
     * This field is only required if your project uses more than one custom domain to send emails.
     */
    domainHint?: string;
};
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, and `Slack`.
 */
declare enum OAuthProviders {
    Google = "google",
    Microsoft = "microsoft",
    Apple = "apple",
    Github = "github",
    GitLab = "gitlab",
    Facebook = "facebook",
    Discord = "discord",
    Slack = "slack",
    Amazon = "amazon",
    Bitbucket = "bitbucket",
    LinkedIn = "linkedin",
    Coinbase = "coinbase",
    Twitch = "twitch"
}
/**
 * The Crypto Wallets we support in our crypto product.
 * Currently we support all ethereum and solana wallets.
 * We additionally detect and show popular wallets as distinct options.
 * The list of poular wallets include `Binance`, `Coinbase`, `Metamask`, `Phantom`, and `Vessel`
 */
declare enum Wallets {
    Vessel = "Vessel",
    Phantom = "Phantom",
    Metamask = "Metamask",
    Coinbase = "Coinbase",
    Binance = "Binance",
    GenericEthereumWallet = "Other Ethereum Wallet",
    GenericSolanaWallet = "Other Solana Wallet"
}
/**
 * For Google One Tap, we support two different position options:
 * `embedded` will display Google One Tap within the existing JavaScript SDK login form
 * `floating` will display the One Tap prompt in the top right corner.
 */
declare enum OneTapPositions {
    embedded = "embedded",
    floating = "floating"
}
type ProviderOptions = {
    type: OAuthProviders;
    one_tap?: boolean;
    position?: OneTapPositions;
    custom_scopes?: string[];
};
/**
 * An array of OAuth providers you wish to use. Each Provider is an object with a type key that
 * determines the type of provider. Each Provider accepts an optional custom_scopes array of
 * scopes that Stytch will request for your application in addition to the base set of scopes
 * required for login. The order of the providers in the array determines the order of the
 * rendered buttons.
 */
type ProvidersOptions = Array<ProviderOptions>;
/**
 * The options for oAuth. This is required if you've enabled the `oauth` product
 * in your configuration.
 */
type OAuthOptions = {
    loginRedirectURL?: string;
    signupRedirectURL?: string;
    providers: ProvidersOptions;
};
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */
declare enum OTPMethods {
    SMS = "sms",
    WhatsApp = "whatsapp",
    Email = "email"
}
/**
 * The options for One Time Passcodes. This is required if you've enabled the `otp` product
 * in your configuration.
 */
type OtpOptions = {
    methods: Array<OTPMethods>;
    expirationMinutes: number;
};
/**
 * The options for passwords. This is required if you've enabled the `passwords` product
 * in your configuration.
 */
type PasswordOptions = {
    loginRedirectURL: string;
    loginExpirationMinutes?: number;
    resetPasswordRedirectURL: string;
    resetPasswordExpirationMinutes?: number;
};
/**
 * The options for Session Management. If you are using the UI components,
 * we also create a session for users when they log in.
 */
type SessionOptions = {
    sessionDurationMinutes: number;
};
/**
 * The configuration object for the Stytch SDK's UI
 */
type StytchLoginConfig = {
    /**
     * The products array allows you to specify the authentication methods that you would like to
     * expose to your users. The order of the products that you include here will also be the order
     * in which they appear in the login form,
     */
    products: Products[];
    emailMagicLinksOptions?: EmailMagicLinksOptions;
    oauthOptions?: OAuthOptions;
    otpOptions?: OtpOptions;
    sessionOptions?: SessionOptions;
    passwordOptions?: PasswordOptions;
};
/**
 * The style configuration allows you to customize the look of the SDK. You can specify some of
 * them or none at all.
 */
type StyleConfig = Partial<{
    /**
     * The font family that will apply to all text in the SDK.
     */
    fontFamily: string;
    /**
     * The width of the SDK UI Container.
     */
    width: string;
    /**
     * Your primary brand color. This color will be applied to primary actions, like buttons.
     */
    primaryColor: string;
    /**
     * The color for the text in the SDK.
     */
    primaryTextColor: string;
    /**
     * The color for secondary text in the SDK, such as disclaimers.
     */
    secondaryTextColor: string;
    /**
     * A light grey color that will be applied to visual elements in the SDK.
     */
    lightGrey: string;
    /**
     * A dark grey color that will be applied to visual elements in the SDK.
     */
    darkGrey: string;
    /**
     * When this value is false, the title and description text will not show in the SDK.
     */
    hideHeaderText: boolean;
}>;
// Callback types
type StytchError = {
    message: string;
};
declare enum StytchEventType {
    MagicLinkLoginOrCreateEvent = "MAGIC_LINK_LOGIN_OR_CREATE",
    OTPsLoginOrCreateEvent = "OTP_LOGIN_OR_CREATE",
    OTPsAuthenticate = "OTP_AUTHENTICATE",
    CryptoWalletAuthenticateStart = "CRYPTO_WALLET_AUTHENTICATE_START",
    CryptoWalletAuthenticate = "CRYPTO_WALLET_AUTHENTICATE",
    PasswordCreate = "PASSWORD_CREATE",
    PasswordAuthenticate = "PASSWORD_AUTHENTICATE",
    PasswordResetByEmailStart = "PASSWORD_RESET_BY_EMAIL_START",
    PasswordResetByEmail = "PASSWORD_RESET_BY_EMAIL"
}
type StytchEvent = {
    type: StytchEventType.MagicLinkLoginOrCreateEvent;
    data: MagicLinksLoginOrCreateResponse;
} | {
    type: StytchEventType.OTPsLoginOrCreateEvent;
    data: OTPsLoginOrCreateResponse;
} | {
    type: StytchEventType.OTPsAuthenticate;
    data: OTPsAuthenticateResponse;
} | {
    type: StytchEventType.CryptoWalletAuthenticateStart;
    data: CryptoWalletAuthenticateStartResponse;
} | {
    type: StytchEventType.CryptoWalletAuthenticate;
    data: CryptoWalletAuthenticateResponse;
} | {
    type: StytchEventType.PasswordCreate;
    data: PasswordCreateResponse;
} | {
    type: StytchEventType.PasswordAuthenticate;
    data: PasswordAuthenticateResponse;
} | {
    type: StytchEventType.PasswordResetByEmailStart;
    data: PasswordResetByEmailStartResponse;
} | {
    type: StytchEventType.PasswordResetByEmail;
    data: PasswordResetByEmailResponse;
};
// More Events will go here ...
/**
 * Optional callbacks that are triggered by various events in the SDK. See more details about the callbacks
 * {@link https://stytch.com/docs/sdks/javascript-sdk#resources_ui-callbacks here}.
 */
type Callbacks = {
    /**
     * A callback function that responds to errors in the SDK. It is useful for debugging during development
     * and error handling in production.
     *
     * @param error - the error from the SDK with an additional error message
     */
    onError?(error: StytchError): void;
    /**
     * A callback function that responds to events sent from the SDK. For the full list of events see the
     * {@link StytchEvent StytchEvent}
     *
     * @param event - the event fired by the SDK
     */
    onEvent?(event: StytchEvent): void;
};
type OneTapStyleConfig = {
    position?: OneTapPositions;
};
/**
 * An Error class thrown when the SDK is unable to reach the Stytch servers,
 * or when the Stytch servers return a value the SDK cannot understand.
 * Usually - it means that you're offline!
 */
declare class SDKAPIUnreachableError extends Error {
    details: string;
    constructor(message: string, details: string);
}
/**
 * An Error class thrown when the provided input fails client-side validation -
 * for example if a field that was expected to be a number is instead a string.
 */
declare class StytchSDKUsageError extends Error {
    constructor(methodName: string, message: string);
}
// Example invalid schema error
// {
//   body: [
//     {
//       keyword: 'type',
//       dataPath: '.session_duration_minutes',
//       schemaPath: '#/properties/session_duration_minutes/type',
//       params: { type: 'number' },
//       message: 'should be number',
//     },
//   ],
// };
// Taken from ajv/lib/ajv.d.ts
interface ErrorObject {
    keyword: string;
    dataPath: string;
    schemaPath: string;
    message?: string;
}
/**
 * An Error class thrown when the provided input does not adhere to the Stytch API schema -
 * for example if a field that was expected to be a number is instead a string.
 */
declare class StytchSDKSchemaError extends Error {
    constructor(schemaError: {
        body?: ErrorObject[];
    });
}
interface APIError {
    status_code: number;
    request_id?: string;
    error_type: string;
    error_message: string;
    error_url: string;
}
/**
 * An Error class wrapping a well-formed JSON error from the Stytch API.
 * The Stytch error should match one listed at {@link https://stytch.com/docs/api/errors}
 */
declare class StytchSDKAPIError extends Error {
    error_type: string;
    error_message: string;
    error_url: string;
    request_id?: string;
    status_code: number;
    constructor(details: APIError);
}
export { ResponseCommon, User, AuthenticateResponse, DeleteResponse, UpdateResponse, SessionDurationOptions, UnsubscribeFunction, EmailFactor, PhoneNumberFactor, GoogleOAuthFactor, MicrosoftOAuthFactor, AppleOAuthFactor, GithubOAuthFactor, GitLabOAuthFactor, FacebookOAuthFactor, DiscordOAuthFactor, SlackOAuthFactor, AmazonOAuthFactor, BitbucketOAuthFactor, LinkedInOAuthFactor, CoinbaseOAuthFactor, TwitchOAuthFactor, WebAuthnFactor, AuthenticatorAppFactor, RecoveryCodeFactor, CryptoWalletFactor, PasswordFactor, AuthenticationFactor, Session, SessionAuthenticateOptions, SessionAuthenticateResponse, SessionRevokeResponse, SessionOnChangeCallback, SessionTokens, IHeadlessSessionClient, OAuthGetURLOptions, OAuthAuthenticateOptions, OAuthAuthenticateResponse, IHeadlessOAuthClient, UserOnChangeCallback, UserUpdateOptions, UserUpdateResponse, IHeadlessUserClient, MagicLinksLoginOrCreateOptions, MagicLinksSendOptions, MagicLinksLoginOrCreateResponse, MagicLinksSendResponse, MagicLinksAuthenticateOptions, MagicLinksAuthenticateResponse, IHeadlessMagicLinksClient, OTPCodeOptions, OTPAuthenticateOptions, OTPsLoginOrCreateResponse, OTPsSendResponse, OTPsAuthenticateResponse, IHeadlessOTPsClient, CryptoWalletAuthenticateStartOptions, CryptoWalletAuthenticateStartResponse, CryptoWalletAuthenticateOptions, CryptoWalletAuthenticateResponse, IHeadlessCryptoWalletClient, TOTPCreateOptions, TOTPCreateResponse, TOTPAuthenticateOptions, TOTPAuthenticateResponse, TOTPRecoveryCodesResponse, TOTPRecoverOptions, TOTPRecoverResponse, IHeadlessTOTPClient, WebAuthnRegisterStartOptions, WebAuthnRegisterStartResponse, WebAuthnRegisterResponse, WebAuthnAuthenticateStartOptions, WebAuthnAuthenticateStartResponse, WebAuthnAuthenticateResponse, IHeadlessWebAuthnClient, PasswordCreateOptions, PasswordCreateResponse, PasswordAuthenticateOptions, PasswordAuthenticateResponse, PasswordResetByEmailStartOptions, PasswordResetByEmailStartResponse, PasswordResetByEmailOptions, PasswordResetByEmailResponse, PasswordResetByExistingPasswordOptions, PasswordResetByExistingPasswordResponse, PasswordResetBySessionOptions, PasswordResetBySessionResponse, PasswordStrengthCheckOptions, PasswordStrengthCheckResponse, IHeadlessPasswordClient, Products, EmailMagicLinksOptions, OAuthProviders, Wallets, OneTapPositions, ProviderOptions, ProvidersOptions, OAuthOptions, OTPMethods, OtpOptions, PasswordOptions, SessionOptions, StytchLoginConfig, StyleConfig, StytchError, StytchEventType, StytchEvent, Callbacks, OneTapStyleConfig, SDKAPIUnreachableError, StytchSDKUsageError, StytchSDKSchemaError, StytchSDKAPIError };
